package com.tmobile.cso.pacman.tenable.jobs;


import com.fasterxml.jackson.databind.ObjectMapper;
import com.tmobile.cso.pacman.tenable.Constants;
import com.tmobile.cso.pacman.tenable.dto.ExportStatus;
import com.tmobile.cso.pacman.tenable.exception.TenableDataImportException;
import com.tmobile.cso.pacman.tenable.exception.UnAuthorisedException;
import com.tmobile.cso.pacman.tenable.util.ElasticSearchManager;
import com.tmobile.cso.pacman.tenable.util.ErrorManageUtil;
import com.tmobile.cso.pacman.tenable.util.HttpUtil;
import com.tmobile.cso.pacman.tenable.util.Util;
import net.minidev.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.CollectionUtils;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.stream.Collectors;

public class TenableVMVulnerabilityDataImporter extends TenableDataImporter {
    private static TenableVMVulnerabilityDataImporter instance = null;
    private static final Logger log = LoggerFactory.getLogger(TenableVMVulnerabilityDataImporter.class);

    private static final String TENABLE_VM_VULNERABILITY = "tenable-vm-vulnerability";
    private static final String TENABLE_VM_ASSET = "tenable-vm-asset";
    private static final String EXPORT_UUID = "export_uuid";
    private static final int ASSETS_EXPORT_RETRY_PERIOD = 20;
    private static final int VULNERABILITIES_EXPORT_RETRY_PERIOD = 20;
    private static final int ASSETS_CHUNK_SIZE = 1000;
    private static final int VULNERABILITIES_CHUNK_SIZE = 1000;
    private static final String EXPORT_STATUS_MESSAGE_TEMPLATE = "Export Status: %s. Export Type: %s. Waiting for %d more seconds to complete ...";
    private static final String INTERRUPTED_MESSAGE_TEMPLATE = "Interrupted! {}";
    private static final List<Map<String, String>> errorList = new ArrayList<>();
    private static final Map<UUID, String> assetMap = new HashMap<>();

    private TenableVMVulnerabilityDataImporter() {
    }

    public static synchronized TenableVMVulnerabilityDataImporter getInstance() {
        if (instance == null) {
            instance = new TenableVMVulnerabilityDataImporter();
        }

        return instance;
    }

    public Map<String, Object> execute(int days) {
        try {
            getAssets();
            getVulnerabilities(days);
        } catch (TenableDataImportException e) {
            log.error("exception while collecting tenable VM Vulnerability Data", e);
            Map<String, String> errorMap = new HashMap<>();
            errorMap.put(Constants.ERROR, "Error in exception while collecting tenable VM Data");
            errorMap.put(Constants.ERROR_TYPE, Constants.FATAL);
            errorMap.put(Constants.EXCEPTION, e.getMessage());
            errorList.add(errorMap);
        }

        return ErrorManageUtil.formErrorCode(errorList);
    }

    private void getAssets() throws TenableDataImportException {
        UUID assetExportIdentifier = triggerAssetExport();
        // TODO: Change so it will be checking and then collecting. Separate into two methods. Same below.
        checkAndExportAssets(assetExportIdentifier);
    }

    private void getVulnerabilities(int days) throws TenableDataImportException {
        UUID vulnerabilityExportIdentifier = triggerVulnerabilityExport(days);
        checkAndExportVulnerabilities(vulnerabilityExportIdentifier);
    }

    private void checkAndExportAssets(UUID assetExportIdentifier) throws TenableDataImportException {
        boolean exportPending = true;
        ExportStatus exportStatus = null;
        while (exportPending) {
            exportStatus = getExportStatus(assetExportIdentifier, "assetsExportStatus");
            switch (exportStatus.getStatus()) {
                case "FINISHED":
                    exportPending = false;
                    break;
                case "FAILED":
                    throw new TenableDataImportException("Asset Export Failed");
                case "CANCELLED":
                    throw new TenableDataImportException("Asset Export Cancelled");
                default:
                    break;
            }

            if(exportPending) {
                try {
                    Thread.sleep(ASSETS_EXPORT_RETRY_PERIOD * 1000);
                    log.info(String.format(EXPORT_STATUS_MESSAGE_TEMPLATE,
                            exportStatus.getStatus(),
                            "Asset",
                            ASSETS_EXPORT_RETRY_PERIOD));
                } catch (InterruptedException e) {
                    log.error(INTERRUPTED_MESSAGE_TEMPLATE, e);
                    Thread.currentThread().interrupt();
                }
            }
        }

        log.info("Asset Export Completed");
        log.info("Chunks Produced (each chunk up to {} items): {}", ASSETS_CHUNK_SIZE, exportStatus.getChunkIds().size());
        List<Map<String, Object>> assets = exportAssets(assetExportIdentifier, exportStatus);
        log.info("Total Assets Exported: {}", assets.size());
        if (!assets.isEmpty()) {
            uploadToES(assets, TENABLE_VM_ASSET, "asset");
        }
    }

    private void checkAndExportVulnerabilities(UUID vulnerabilityExportIdentifier) throws TenableDataImportException {
        boolean exportPending = true;
        ExportStatus exportStatus = null;
        while (exportPending) {
            exportStatus = getExportStatus(vulnerabilityExportIdentifier, "vulnerabilityExportStatus");
            switch (exportStatus.getStatus()) {
                case "FINISHED":
                    exportPending = false;
                    break;
                case "FAILED":
                    throw new TenableDataImportException("Vulnerability Export Failed");
                case "CANCELLED":
                    throw new TenableDataImportException("Vulnerability Export Cancelled");
                default:
                    break;
            }
            if(exportPending) {
                try {
                    Thread.sleep(VULNERABILITIES_EXPORT_RETRY_PERIOD * 1000);
                    log.info(String.format(EXPORT_STATUS_MESSAGE_TEMPLATE,
                            exportStatus.getStatus(),
                            "Vulnerability",
                            VULNERABILITIES_EXPORT_RETRY_PERIOD));
                } catch (InterruptedException e) {
                    log.error(INTERRUPTED_MESSAGE_TEMPLATE, e);
                    Thread.currentThread().interrupt();
                }
            }
        }

        log.info("Vulnerability Export Completed");
        log.info("Chunks Produced (each chunk up to {} items): {}", VULNERABILITIES_CHUNK_SIZE, exportStatus.getChunkIds().size());
        List<Map<String, Object>> vulnerabilities = exportVulnerabilities(vulnerabilityExportIdentifier, exportStatus);
        log.info("Total Vulnerabilities Exported: {}", vulnerabilities.size());
        if (!vulnerabilities.isEmpty()) {
            uploadToES(vulnerabilities, TENABLE_VM_VULNERABILITY, "vulnerability");
        }
    }

    private List<Map<String, Object>> exportAssets(UUID exportId, ExportStatus exportStatus) throws TenableDataImportException {
        List<Map<String, Object>> result = new ArrayList<>();
        if (exportStatus != null) {
            for (Integer chunkId : exportStatus.getChunkIds()) {
                log.info("Exporting Assets Chunk -> {}", chunkId);
                String assetsExportApiPath = apiMap.get("assetsExport")
                        .replace("{export_id}", exportId.toString())
                        .replace("{chunk_id}", chunkId.toString());
                String assetExportApiUrl = getTenableApiUrl(assetsExportApiPath);
                try {
                    Map<String, String> input = getBaseTenableInput();
                    String response = HttpUtil.get(assetExportApiUrl, input);
                    List<Map<String, Object>> parsedResponse = (List<Map<String, Object>>) Util.getJsonBuilder().fromJson(response, List.class);
                    log.info("Exported Assets Chunk -> Id:{}, Size:{}", chunkId, parsedResponse.size());
                    if (!parsedResponse.isEmpty()) {
                        List<Map<String, Object>> filteredResponse = parsedResponse
                                .stream()
                                .filter(asset -> ((List<String>) asset.get("system_types")).contains("aws-ec2-instance"))
                                .collect(Collectors.toList());
                        assetMap.putAll(
                                filteredResponse
                                        .stream()
                                        .collect(Collectors.toMap(
                                                asset -> UUID.fromString(asset.get("id").toString()),
                                                asset -> asset.get("aws_ec2_instance_id").toString())));
                        result.addAll(filteredResponse);
                    } else {
                        throw new TenableDataImportException("Unable to exports Assets");
                    }
                } catch (IOException | UnAuthorisedException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            throw new TenableDataImportException("Unable to exports Assets");
        }

        return result;
    }

    private List<Map<String, Object>> exportVulnerabilities(UUID exportId, ExportStatus exportStatus) throws TenableDataImportException {
        List<Map<String, Object>> response = new ArrayList<>();
        if (exportStatus != null) {
            for (Integer chunkId : exportStatus.getChunkIds()) {
                log.info("Exporting Vulnerabilities Chunk -> {}", chunkId);
                String vulnerabilityExportApiPath = apiMap.get("vulnerabilityExport")
                        .replace("{export_id}", exportId.toString())
                        .replace("{chunk_id}", chunkId.toString());
                String vulnerabilityExportApiUrl = getTenableApiUrl(vulnerabilityExportApiPath);
                Map<String, String> input = getBaseTenableInput();
                try {
                    String responseString = HttpUtil.get(vulnerabilityExportApiUrl, input);
                    List<Map<String, Object>> parsedResponse = (List<Map<String, Object>>) Util.getJsonBuilder().fromJson(responseString, List.class);
                    log.info("Exported Vulnerabilities Chunk -> Id:{}, Size:{}", chunkId, parsedResponse.size());
                    if (!parsedResponse.isEmpty()) {
                        parsedResponse.stream()
                                .forEach(vulnerability ->
                                        ((Map<String, Object>) vulnerability.get("asset"))
                                                .put("instanceId", assetMap.get(UUID.fromString(((Map<String, Object>) vulnerability.get("asset")).get("uuid").toString()))));
                        response.addAll(parsedResponse);
                    } else {
                        throw new TenableDataImportException("Unable to exports Vulnerabilities");
                    }
                } catch (IOException | UnAuthorisedException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            throw new TenableDataImportException("Unable to exports Vulnerabilities");
        }

        return response;
    }

    private ExportStatus getExportStatus(UUID exportId, String apiMapKey) throws TenableDataImportException {
        try {
            String exportStatusApiPath = apiMap.get(apiMapKey)
                    .replace("{export_id}", exportId.toString());
            String exportStatusApiUrl = getTenableApiUrl(exportStatusApiPath);
            Map<String, String> input = getBaseTenableInput();
            ExportStatus response = Util.getJsonBuilder().fromJson(HttpUtil.get(exportStatusApiUrl, input), ExportStatus.class);
            if (response != null) {
                return response;
            } else {
                throw new TenableDataImportException("Unable to get the Export Status from " + exportStatusApiPath);
            }
        } catch (UnAuthorisedException | IOException e) {
            throw new TenableDataImportException("Failed to fetch export status", e);
        }
    }

    private static String getTenableApiUrl(String apiPath) {
        String tenableApiUrl = TENABLE_API_URL + apiPath;
        return tenableApiUrl;
    }

    private UUID triggerAssetExport() throws TenableDataImportException {
        // TODO: We should see how we can add filters here because gathering all assets all the time is not a good idea (per Tenable)
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("chunk_size", ASSETS_CHUNK_SIZE);
        jsonObject.put("include_unlicensed", true);
        String requestBody = jsonObject.toString();
        if (Constants.IS_DEBUG_MODE) {
            log.debug("Asset Export Request Body -> {}", requestBody);
        }

        Map<String, String> input = getBaseTenableInput();

        try {
            String assetExportApiPath = apiMap.get("assetsExportTrigger");
            String assetExportApiUrl = getTenableApiUrl(assetExportApiPath);
            if (Constants.IS_DEBUG_MODE) {
                log.debug("Asset Export Url -> {}", assetExportApiUrl);
            }

            String response = HttpUtil.post(assetExportApiUrl, requestBody, input);
            if (Constants.IS_DEBUG_MODE) {
                log.info("Asset Export Response -> {}", response);
            }

            Map<String, Object> parsedResponse = ((Map<String, Object>) Util.getJsonBuilder().fromJson(response, Map.class));
            if (parsedResponse != null && parsedResponse.get(EXPORT_UUID) != null) {
                return UUID.fromString(parsedResponse.get(EXPORT_UUID).toString());
            } else {
                String errorMessage = "Unable to trigger Asset Export. Status: "
                        + parsedResponse.getOrDefault("status", "UNKNOWN")
                        + ", Message: "
                        + parsedResponse.getOrDefault("message", "UNKNOWN");
                throw new TenableDataImportException(errorMessage);
            }
        } catch (UnAuthorisedException e) {
            log.info("Exception while triggering Asset Export -> {}", e.toString());
            throw new TenableDataImportException("UnAuthorisedException: " + e.getMessage());
        } catch (Exception e) {
            log.info("Exception while triggering Asset Export -> {}", e.toString());
            throw new TenableDataImportException("Exception: " + e.getMessage());
        }
    }

    private static Map<String, String> getBaseTenableInput() {
        Map<String, String> input = new HashMap<>();
        input.put(Constants.X_API_KEYS_HEADER_NAME, X_API_KEYS);
        input.put(Constants.USER_AGENT_HEADER_NAME, USER_AGENT);
        return input;
    }

    private UUID triggerVulnerabilityExport(int days) throws TenableDataImportException {
        String vulnerabilityExportTrigger = apiMap.get("vulnerabilityExportTrigger");
        String vulnerabilityExportTriggerUrl = getTenableApiUrl(vulnerabilityExportTrigger);
        JSONObject jsonObject = new JSONObject();
        JSONObject filters = new JSONObject();

        // @TODO we can monitor and tune this
        jsonObject.put(
                "num_assets",
                assetMap.keySet().size() < VULNERABILITIES_CHUNK_SIZE ? assetMap.keySet().size() : VULNERABILITIES_CHUNK_SIZE);
        filters.put("severity", Arrays.asList("low", "medium", "high", "critical"));

        // @TODO now considering 1 yrs old data we have to make it configurable
        filters.put("since", calculateTimeRange(days));
        jsonObject.put("filters", filters);
        jsonObject.put("include_unlicensed", true);
        String requestBody = jsonObject.toString();
        if (Constants.IS_DEBUG_MODE)
            log.debug("Vulnerability Export Request Body -> {}", requestBody);

        Map<String, String> input = getBaseTenableInput();

        try {
            String response = HttpUtil.post(vulnerabilityExportTriggerUrl, requestBody, input);
            Map<String, Object> parsedResponse = ((Map<String, Object>) Util.getJsonBuilder().fromJson(response, Map.class));
            if (parsedResponse != null && parsedResponse.get(EXPORT_UUID) != null) {
                return UUID.fromString(parsedResponse.get(EXPORT_UUID).toString());
            } else {
                String errorMessage = "Unable to trigger Vulnerability Export. Status: "
                        + parsedResponse.getOrDefault("status", "UNKNOWN")
                        + ", Message: "
                        + parsedResponse.getOrDefault("message", "UNKNOWN");
                throw new TenableDataImportException(errorMessage);
            }
        } catch (UnAuthorisedException e) {
            log.info("Exception while triggering Vulnerability Export -> {}", e.toString());
            throw new TenableDataImportException("UnAuthorisedException: " + e.getMessage());
        } catch (Exception e) {
            log.info("Exception while triggering Vulnerability Export -> {}", e.toString());
            throw new TenableDataImportException("Exception: " + e.getMessage());
        }
    }

    private long calculateTimeRange(int days) {
        final LocalDate now = LocalDate.now();
        LocalDate yesterday;
        ZonedDateTime startOfDayInZone;
        if (!ElasticSearchManager.indexExists("/" + TENABLE_VM_VULNERABILITY)) {
            return 0;
        } else {
            yesterday = now.minusDays(days);
            startOfDayInZone = yesterday.atStartOfDay(ZoneId.systemDefault());
        }

        return startOfDayInZone.toEpochSecond();
    }

    private void uploadToES(List<Map<String, Object>> result, String indexName, String dataType) throws TenableDataImportException {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));

            List<Map<String, Object>> details = new ArrayList<>();
            synchronized (Collections.unmodifiableList(details)) {
                for (Map<String, Object> res : result) {
                    String idValue = dataType == "vulnerability" ? buildIDValue(res) : res.get("id").toString();
                    res.putIfAbsent("idKey", idValue);
                    details.add(res);
                }
            }

            log.info("Total " + dataType + " to be uploaded: {}", details.size());
            ElasticSearchManager.createIndex(indexName);
            ElasticSearchManager.uploadData(indexName, dataType, details, "idKey");
        } catch (Exception e) {
            throw new TenableDataImportException("Failed to Upload Tenable VM " + dataType + " data to ES", e);
        }
    }

    private String buildIDValue(Map<String, Object> res) {
        Map<String, Object> assetData = (Map<String, Object>) res.get("asset");
        String pluginId = ((Map<String, Object>) res.get("plugin")).get("id").toString();
        String assetId = (String) assetData.get("uuid");
        return assetId + "-" + pluginId;
    }
}
