package com.tmobile.cso.pacman.tenable.jobs;


import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.tmobile.cso.pacman.tenable.Constants;
import com.tmobile.cso.pacman.tenable.dto.ExportStatus;
import com.tmobile.cso.pacman.tenable.exception.TenableDataImportException;
import com.tmobile.cso.pacman.tenable.exception.UnAuthorisedException;
import com.tmobile.cso.pacman.tenable.util.ElasticSearchManager;
import com.tmobile.cso.pacman.tenable.util.ErrorManageUtil;
import com.tmobile.cso.pacman.tenable.util.HttpUtil;
import com.tmobile.cso.pacman.tenable.util.Util;
import net.minidev.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.CollectionUtils;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.stream.Collectors;

public class TenableVMVulnerabilityDataImporter extends TenableDataImporter {
    private static TenableVMVulnerabilityDataImporter instance = null;
    private static final Logger log = LoggerFactory.getLogger(TenableVMVulnerabilityDataImporter.class);

    private static final String TENABLE_VM_VULNERABILITY = "tenable-vm-vulnerability";
    private static final String EXPORT_UUID = "export_uuid";
    private static final int ASSETS_EXPORT_RETRY_PERIOD = 20;
    private static final int VULNERABILITIES_EXPORT_RETRY_PERIOD = 20;
    private static final int ASSETS_CHUNK_SIZE = 1000;
    private static final int VULNERABILITIES_CHUNK_SIZE = 1000;
    private static final String EXPORT_STATUS_MESSAGE_TEMPLATE = "Export Status: %s. Export Type: %s. Waiting for %d more seconds to complete ...";
    private static final List<Map<String, String>> errorList = new ArrayList<>();
    private static final Map<UUID, String> assetMap = new HashMap<>();

    private TenableVMVulnerabilityDataImporter() {
    }

    public static synchronized TenableVMVulnerabilityDataImporter getInstance() {
        if (instance == null)
            instance = new TenableVMVulnerabilityDataImporter();

        return instance;
    }

    public Map<String, Object> execute(int days) {
        try {
            getAssets();
            getVulnerabilities(days);
        } catch (TenableDataImportException e) {
            log.error("exception while collecting tenable VM Vulnerability Data", e);
            Map<String, String> errorMap = new HashMap<>();
            errorMap.put(Constants.ERROR, "Error in exception while collecting tenable VM Vulnerability Data");
            errorMap.put(Constants.ERROR_TYPE, Constants.FATAL);
            errorMap.put(Constants.EXCEPTION, e.getMessage());
            errorList.add(errorMap);
        }

        return ErrorManageUtil.formErrorCode(errorList);
    }

    private void getAssets() throws TenableDataImportException {
        UUID assetExportIdentifier = triggerAssetExport();
        checkAndExportAssets(assetExportIdentifier);
    }

    private void getVulnerabilities(int days) throws TenableDataImportException {
        UUID vulnerabilityExportIdentifier = triggerVulnerabilityExport(days);
        checkAndExportVulnerabilities(vulnerabilityExportIdentifier);
    }

    private void checkAndExportAssets(UUID assetExportIdentifier) throws TenableDataImportException {
        boolean assetExportPending = true;
        ExportStatus exportStatus = null;
        while (assetExportPending) {
            exportStatus = isAssetsExported(assetExportIdentifier);
            switch (exportStatus.getStatus()) {
                case "FINISHED":
                    assetExportPending = false;
                    break;
                case "FAILED":
                    throw new TenableDataImportException("Asset Export Failed");
                case "CANCELLED":
                    throw new TenableDataImportException("Asset Export Cancelled");
                default:
                    break;
            }

            try {
                Thread.sleep(ASSETS_EXPORT_RETRY_PERIOD * 1000);
                log.info(String.format(EXPORT_STATUS_MESSAGE_TEMPLATE,
                        exportStatus.getStatus(),
                        "Asset",
                        ASSETS_EXPORT_RETRY_PERIOD));
            } catch (InterruptedException e) {
                log.error("Interrupted! {}", e);
                Thread.currentThread().interrupt();
            }
        }

        log.info("Asset Export Completed");
        log.info("Chunks Produced (each chunk up to {} items): {}", ASSETS_CHUNK_SIZE, exportStatus.getChunkIds().size());
        exportAssets(assetExportIdentifier, exportStatus);
    }

    private void checkAndExportVulnerabilities(UUID vulnerabilityExportIdentifier) throws TenableDataImportException {
        boolean exportPending = true;
        ExportStatus exportStatus = null;
        while (exportPending) {
            exportStatus = isVulnerabilitiesExported(vulnerabilityExportIdentifier);
            switch (exportStatus.getStatus()) {
                case "FINISHED":
                    exportPending = false;
                    break;
                case "FAILED":
                    throw new TenableDataImportException("Vulnerability Export Failed");
                case "CANCELLED":
                    throw new TenableDataImportException("Vulnerability Export Cancelled");
                default:
                    break;
            }

            try {
                Thread.sleep(VULNERABILITIES_EXPORT_RETRY_PERIOD * 1000);
                log.info(String.format(EXPORT_STATUS_MESSAGE_TEMPLATE,
                        exportStatus.getStatus(),
                        "Vulnerability",
                        VULNERABILITIES_EXPORT_RETRY_PERIOD));
            } catch (InterruptedException e) {
                log.error("Interrupted! {}", e);
                Thread.currentThread().interrupt();
            }
        }

        log.info("Vulnerability Export Completed");
        log.info("Chunks Produced (each chunk up to {} items): {}", VULNERABILITIES_CHUNK_SIZE, exportStatus.getChunkIds().size());
        List<Map<String, Object>> vulnerabilities = exportVulnerabilities(vulnerabilityExportIdentifier, exportStatus);
        log.info("Total Vulnerabilities Exported: {}", vulnerabilities.size());
        if (!CollectionUtils.isEmpty(vulnerabilities)) {
            uploadToES(vulnerabilities);
        }
    }

    private void exportAssets(UUID exportId, ExportStatus exportStatus) throws TenableDataImportException {
        if (exportStatus != null) {
            Gson gson = Util.getJsonBuilder();
            for (Integer chunkId : exportStatus.getChunkIds()) {
                log.info("Exporting Assets Chunk -> {}", chunkId);
                String assetsExportApi = apiMap.get("assetsExport");
                assetsExportApi = assetsExportApi.replace("{export_id}", exportId.toString()).replace("{chunk_id}", chunkId.toString());
                String assetExportURL = TENABLE_API_URL + assetsExportApi;
                Map<String, String> input = new HashMap<>();
                input.put(Constants.TENABLE_API_KEYS, API_KEYS);
                input.put(Constants.USER_AGENT, USER_AGENT);
                try {
                    String response = HttpUtil.get(assetExportURL, input);
                    List<Map<String, Object>> parsedResponse = (List<Map<String, Object>>) gson.fromJson(response, List.class);
                    log.info("Exported Assets Chunk -> Id:{}, Size:{}", chunkId, parsedResponse.size());
                    if (!CollectionUtils.isEmpty(parsedResponse)) {
                        assetMap.putAll(parsedResponse.stream()
                                .filter(asset -> ((List<String>) asset.get("system_types")).contains("aws-ec2-instance"))
                                .collect(Collectors.toMap(asset -> UUID.fromString(asset.get("id").toString()), asset -> asset.get("aws_ec2_instance_id").toString())));
                    } else {
                        throw new TenableDataImportException("Unable to exports Assets");
                    }
                } catch (IOException | UnAuthorisedException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            throw new TenableDataImportException("Unable to exports Assets");
        }
    }

    private List<Map<String, Object>> exportVulnerabilities(UUID exportId, ExportStatus exportStatus) throws TenableDataImportException {
        List<Map<String, Object>> response = new ArrayList<>();
        if (exportStatus != null) {
            Gson gson = Util.getJsonBuilder();
            for (Integer chunkId : exportStatus.getChunkIds()) {
                log.info("Exporting Vulnerabilities Chunk -> {}", chunkId);
                String vulnerabilityExport = apiMap.get("vulnerabilityExport");
                vulnerabilityExport = vulnerabilityExport.replace("{export_id}", exportId.toString());
                vulnerabilityExport = vulnerabilityExport.replace("{chunk_id}", chunkId.toString());
                String vulnerabilityExportURL = TENABLE_API_URL + vulnerabilityExport;
                Map<String, String> input = new HashMap<>();
                input.put(Constants.TENABLE_API_KEYS, API_KEYS);
                input.put(Constants.USER_AGENT, USER_AGENT);
                try {
                    String responseString = HttpUtil.get(vulnerabilityExportURL, input);
                    List<Map<String, Object>> parsedResponse = (List<Map<String, Object>>) gson.fromJson(responseString, List.class);
                    log.info("Exported Vulnerabilities Chunk -> Id:{}, Size:{}", chunkId, parsedResponse.size());
                    if (!CollectionUtils.isEmpty(parsedResponse)) {
                        parsedResponse.stream()
                                .forEach(vulnerability ->
                                        ((Map<String, Object>) vulnerability.get("asset"))
                                                .put("instanceId", assetMap.get(UUID.fromString(((Map<String, Object>) vulnerability.get("asset")).get("uuid").toString()))));
                        response.addAll(parsedResponse);
                    } else {
                        throw new TenableDataImportException("Unable to exports Vulnerabilities");
                    }
                } catch (IOException | UnAuthorisedException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            throw new TenableDataImportException("Unable to exports Vulnerabilities");
        }

        return response;
    }

    private ExportStatus isAssetsExported(UUID assetExportIdentifier) throws TenableDataImportException {
        Gson gson = Util.getJsonBuilder();
        String assetExportStatus = apiMap.get("assetsExportStatus").replace("{export_id}", assetExportIdentifier.toString());
        String assetExportStatusURL = TENABLE_API_URL + assetExportStatus;
        Map<String, String> input = new HashMap<>();
        input.put(Constants.TENABLE_API_KEYS, API_KEYS);
        input.put(Constants.USER_AGENT, USER_AGENT);

        try {
            ExportStatus response = gson.fromJson(HttpUtil.get(assetExportStatusURL, input), ExportStatus.class);
            if (response != null) {
                return response;
            } else {
                throw new TenableDataImportException("Unable to get the  Asset Export Status");
            }
        } catch (UnAuthorisedException | IOException e) {
            throw new TenableDataImportException("Failed to fetch asset export status", e);
        }
    }

    private ExportStatus isVulnerabilitiesExported(UUID vulnerabilityExportIdentifier) throws TenableDataImportException {
        Gson gson = Util.getJsonBuilder();
        String vulnerabilityExportStatus = apiMap.get("vulnerabilityExportStatus").replace("{export_id}", vulnerabilityExportIdentifier.toString());
        String vulnerabilitiesExportStatusURL = TENABLE_API_URL + vulnerabilityExportStatus;
        Map<String, String> input = new HashMap<>();
        input.put(Constants.TENABLE_API_KEYS, API_KEYS);
        input.put(Constants.USER_AGENT, USER_AGENT);

        try {
            ExportStatus response = gson.fromJson(HttpUtil.get(vulnerabilitiesExportStatusURL, input), ExportStatus.class);
            if (response != null) {
                return response;
            } else {
                throw new TenableDataImportException("Unable to get the  Asset Export Status");
            }
        } catch (UnAuthorisedException | IOException e) {
            throw new TenableDataImportException("Failed to fetch asset export status", e);
        }
    }

    private UUID triggerAssetExport() throws TenableDataImportException {
        Gson gson = Util.getJsonBuilder();

        String assetExport = apiMap.get("assetsExportTrigger");
        String assetExportURL = TENABLE_API_URL + assetExport;
        if (Constants.IS_DEBUG_MODE)
            log.debug("Asset Export URL -> {}", assetExportURL);

        // TODO: We should see how we can add filters here because gathering all assets all the time is not a good idea (per Tenable)
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("chunk_size", ASSETS_CHUNK_SIZE);
        jsonObject.put("include_unlicensed", true);
        String requestBody = jsonObject.toString();
        if (Constants.IS_DEBUG_MODE)
            log.debug("Asset Export Request Body -> {}", requestBody);

        Map<String, String> input = new HashMap<>();
        input.put(Constants.TENABLE_API_KEYS, API_KEYS);
        input.put(Constants.USER_AGENT, USER_AGENT);

        try {
            String response = HttpUtil.post(assetExportURL, requestBody, input);
            if (Constants.IS_DEBUG_MODE)
                log.info("Asset Export Response -> {}", response);

            Map<String, Object> parsedResponse = ((Map<String, Object>) gson.fromJson(response, Map.class));
            if (parsedResponse != null && parsedResponse.get(EXPORT_UUID) != null) {
                return UUID.fromString(parsedResponse.get(EXPORT_UUID).toString());
            } else {
                String errorMessage = "Unable to trigger Asset Export. Status: "
                        + parsedResponse.getOrDefault("status", "UNKNOWN")
                        + ", Message: "
                        + parsedResponse.getOrDefault("message", "UNKNOWN");
                throw new TenableDataImportException(errorMessage);
            }
        } catch (UnAuthorisedException e) {
            log.info("Exception while triggering Asset Export -> {}", e.toString());
            throw new TenableDataImportException("UnAuthorisedException: " + e.getMessage());
        } catch (Exception e) {
            log.info("Exception while triggering Asset Export -> {}", e.toString());
            throw new TenableDataImportException("Exception: " + e.getMessage());
        }
    }

    private UUID triggerVulnerabilityExport(int days) throws TenableDataImportException {
        Gson gson = Util.getJsonBuilder();
        String vulnerabilityExportTrigger = apiMap.get("vulnerabilityExportTrigger");
        String vulnerabilityExportTriggerURL = TENABLE_API_URL + vulnerabilityExportTrigger;
        JSONObject jsonObject = new JSONObject();
        JSONObject filters = new JSONObject();

        // @TODO we can monitor and tune this
        jsonObject.put(
                "num_assets",
                assetMap.keySet().size() < VULNERABILITIES_CHUNK_SIZE ? assetMap.keySet().size() : VULNERABILITIES_CHUNK_SIZE);
        filters.put("severity", Arrays.asList("low", "medium", "high", "critical"));

        // @TODO now considering 1 yrs old data we have to make it configurable
        filters.put("since", calculateTimeRange(days));
        jsonObject.put("filters", filters);
        jsonObject.put("include_unlicensed", true);
        String requestBody = jsonObject.toString();

        Map<String, String> input = new HashMap<>();
        input.put(Constants.TENABLE_API_KEYS, API_KEYS);
        input.put(Constants.USER_AGENT, USER_AGENT);

        try {
            String response = HttpUtil.post(vulnerabilityExportTriggerURL, requestBody, input);
            Map<String, Object> parsedResponse = ((Map<String, Object>) gson.fromJson(response, Map.class));
            if (parsedResponse != null && parsedResponse.get(EXPORT_UUID) != null) {
                return UUID.fromString(parsedResponse.get(EXPORT_UUID).toString());
            } else {
                String errorMessage = "Unable to trigger Vulnerability Export. Status: "
                        + parsedResponse.getOrDefault("status", "UNKNOWN")
                        + ", Message: "
                        + parsedResponse.getOrDefault("message", "UNKNOWN");
                throw new TenableDataImportException(errorMessage);
            }
        } catch (UnAuthorisedException e) {
            log.info("Exception while triggering Vulnerability Export -> {}", e.toString());
            throw new TenableDataImportException("UnAuthorisedException: " + e.getMessage());
        } catch (Exception e) {
            log.info("Exception while triggering Vulnerability Export -> {}", e.toString());
            throw new TenableDataImportException("Exception: " + e.getMessage());
        }
    }

    private long calculateTimeRange(int days) {
        final LocalDate now = LocalDate.now();
        LocalDate yesterday;
        ZonedDateTime startOfDayInZone;
        if (!ElasticSearchManager.indexExists("/" + TENABLE_VM_VULNERABILITY)) {
            return 0;
        } else {
            yesterday = now.minusDays(days);
            startOfDayInZone = yesterday.atStartOfDay(ZoneId.systemDefault());
        }

        return startOfDayInZone.toEpochSecond();
    }

    private void uploadToES(List<Map<String, Object>> result) throws TenableDataImportException {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));

            List<Map<String, Object>> vulnerabilityDetails = new ArrayList<>();
            synchronized (Collections.unmodifiableList(vulnerabilityDetails)) {
                for (Map<String, Object> res : result) {
                    String idValue = buildIDValue(res);
                    res.putIfAbsent("idKey", idValue);
                    vulnerabilityDetails.add(res);
                }
            }

            log.info("Total Vulnerabilities to be uploaded: {}", vulnerabilityDetails.size());
            ElasticSearchManager.createIndex(TENABLE_VM_VULNERABILITY);
            ElasticSearchManager.uploadData(TENABLE_VM_VULNERABILITY, "vulnerability", vulnerabilityDetails, "idKey");
        } catch (Exception e) {
            throw new TenableDataImportException("Failed to Upload Tenable VM Vulnerability data to ES", e);
        }
    }

    private String buildIDValue(Map<String, Object> res) {
        Map<String, Object> assetData = (Map<String, Object>) res.get("asset");
        String pluginId = ((Map<String, Object>) res.get("plugin")).get("id").toString();
        String assetId = (String) assetData.get("uuid");
        return assetId + "-" + pluginId;
    }
}
