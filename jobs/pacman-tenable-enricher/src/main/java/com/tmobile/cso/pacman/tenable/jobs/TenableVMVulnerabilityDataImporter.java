package com.tmobile.cso.pacman.tenable.jobs;


import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.tmobile.cso.pacman.tenable.Constants;
import com.tmobile.cso.pacman.tenable.dto.ExportStatus;
import com.tmobile.cso.pacman.tenable.exception.TenableDataImportException;
import com.tmobile.cso.pacman.tenable.exception.UnAuthorisedException;
import com.tmobile.cso.pacman.tenable.util.ElasticSearchManager;
import com.tmobile.cso.pacman.tenable.util.ErrorManageUtil;
import com.tmobile.cso.pacman.tenable.util.HttpUtil;
import com.tmobile.cso.pacman.tenable.util.Util;
import net.minidev.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.CollectionUtils;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

public class TenableVMVulnerabilityDataImporter extends TenableDataImporter {


    private static final Logger log = LoggerFactory.getLogger(TenableVMVulnerabilityDataImporter.class);

    /**
     * The Constant index.
     */
    private final static String TENABLE_VM_VULNERABILITY = "tenable-vm-vulnerability";

    /**
     * The Constant type.
     */
    private final static String TYPE = "vulnerability";

    /**
     * The Constant docid.
     */
    private final static String DOC_ID = "idKey";

    private static List<Map<String, String>> errorList = new ArrayList<>();

    private static Map<UUID, String> assetMap = new HashMap<>();

    public Map<String, Object> execute(int days) {
        try {
            getAssets();
            getVulnerabilities(days);
        } catch (TenableDataImportException e) {
            log.error("exception while collecting tenable VM Vulnerability Data", e);
            Map<String, String> errorMap = new HashMap<>();
            errorMap.put(Constants.ERROR, "Error in exception while collecting tenable VM Vulnerability Data");
            errorMap.put(Constants.ERROR_TYPE, Constants.FATAL);
            errorMap.put(Constants.EXCEPTION, e.getMessage());
            errorList.add(errorMap);
        }
        return ErrorManageUtil.formErrorCode(errorList);
    }

    private void getAssets() throws TenableDataImportException {
        UUID assetExportIdentifier = triggerAssetExport();
        checkAndExportAssets(assetExportIdentifier);
    }

    private void getVulnerabilities(int days) throws TenableDataImportException {
        UUID vulnerabilityExportIdentifier = triggerVulnerabilityExport(days);
        checkAndExportVulnerabilities(vulnerabilityExportIdentifier);
    }

    private void checkAndExportAssets(UUID assetExportIdentifier) throws TenableDataImportException {
        boolean assetExportPending = true;
        ExportStatus exportStatus = null;
        while (assetExportPending) {
            exportStatus = isAssetsExported(assetExportIdentifier);
            if (exportStatus.getStatus().equals("FINISHED")) {
                assetExportPending = false;
            }
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                log.error( "Interrupted! {}", e);
                Thread.currentThread().interrupt();
            }
        }
        exportAssets(assetExportIdentifier, exportStatus);
    }

    private void checkAndExportVulnerabilities(UUID vulnerabilityExportIdentifier) throws TenableDataImportException {
        boolean exportPending = true;
        ExportStatus exportStatus = null;
        while (exportPending) {
            exportStatus = isVulnerabilitiesExported(vulnerabilityExportIdentifier);
            if (exportStatus.getStatus().equals("FINISHED")) {
                exportPending = false;
            }
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                log.error( "Interrupted! {}", e);
                Thread.currentThread().interrupt();
            }
        }
        List<Map<String, Object>> vulnerabilities = exportVulnerabilities(vulnerabilityExportIdentifier, exportStatus);
        if(!CollectionUtils.isEmpty(vulnerabilities)){
            uploadToES(vulnerabilities);
        }
    }

    private void exportAssets(UUID exportId, ExportStatus exportStatus) throws TenableDataImportException {
        if (exportStatus != null) {
            Gson gson = Util.getJsonBuilder();
            for (Integer chunkId : exportStatus.getChunkIds()) {
                String assetsExportApi = apiMap.get("assetsExport");
                assetsExportApi = assetsExportApi.replace("{export_id}", exportId.toString());
                assetsExportApi = assetsExportApi.replace("{chunk_id}", chunkId.toString());
                String assetExportURL = TENABLE_API_URL + assetsExportApi;
                Map<String , String > input = new HashMap<>();
                input.put(Constants.TENABLE_API_KEYS,API_KEYS);
                input.put(Constants.USER_AGENT,USER_AGENT);
                try {
                    List<Map<String, Object>> response = ((List<Map<String, Object>>) gson.fromJson(HttpUtil.get(assetExportURL, input), List.class));
                    if (!CollectionUtils.isEmpty(response)) {
                        assetMap.putAll(response.stream()
                                .filter(asset -> ((List<String>) asset.get("system_types")).contains("aws-ec2-instance"))
                                .collect(Collectors.toMap(asset -> UUID.fromString(asset.get("id").toString()), asset -> asset.get("aws_ec2_instance_id").toString())));
                    } else {
                        throw new TenableDataImportException("Unable to exports Assets");
                    }
                } catch (IOException | UnAuthorisedException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            throw new TenableDataImportException("Unable to exports Assets");
        }
    }


    private List<Map<String, Object>> exportVulnerabilities(UUID exportId, ExportStatus exportStatus) throws TenableDataImportException {
        List<Map<String, Object>> response =new ArrayList<>();
        if (exportStatus != null) {
            Gson gson = Util.getJsonBuilder();
            for (Integer chunkId : exportStatus.getChunkIds()) {
                String vulnerabilityExport = apiMap.get("vulnerabilityExport");
                vulnerabilityExport = vulnerabilityExport.replace("{export_id}", exportId.toString());
                vulnerabilityExport = vulnerabilityExport.replace("{chunk_id}", chunkId.toString());
                String vulnerabilityExportURL = TENABLE_API_URL + vulnerabilityExport;
                Map<String , String > input = new HashMap<>();
                input.put(Constants.TENABLE_API_KEYS,API_KEYS);
                input.put(Constants.USER_AGENT,USER_AGENT);
                try {
                    List<Map<String, Object>> chunkResponse = ((List<Map<String, Object>>) gson.fromJson(HttpUtil.get(vulnerabilityExportURL, input), List.class));
                    if (!CollectionUtils.isEmpty(chunkResponse)) {
                        chunkResponse.stream()
                                .forEach(vulnerability ->
                                        ((Map<String,Object>)vulnerability.get("asset"))
                                                .put("instanceId",assetMap.get(UUID.fromString(((Map<String,Object>)vulnerability.get("asset")).get("uuid").toString()))));
                        response.addAll(chunkResponse);
                    } else {
                        throw new TenableDataImportException("Unable to exports Vulnerabilities");
                    }

                } catch (IOException | UnAuthorisedException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            throw new TenableDataImportException("Unable to exports Vulnerabilities");
        }
        return response;
    }




    private ExportStatus isAssetsExported(UUID assetExportIdentifier) throws TenableDataImportException {

        Gson gson = Util.getJsonBuilder();
        String assetExportStatus = apiMap.get("assetsExportStatus");
        assetExportStatus = assetExportStatus.replace("{export_id}", assetExportIdentifier.toString());
        String assetExportStatusURL = TENABLE_API_URL + assetExportStatus;
        Map<String , String > input = new HashMap<>();
        input.put(Constants.TENABLE_API_KEYS,API_KEYS);
        input.put(Constants.USER_AGENT,USER_AGENT);
        try {
            ExportStatus response = gson.fromJson(HttpUtil.get(assetExportStatusURL, input), ExportStatus.class);
            if (response != null) {
                return response;
            } else {
                throw new TenableDataImportException("Unable to get the  Asset Export Status");
            }
        } catch (UnAuthorisedException | IOException e) {
            throw new TenableDataImportException("Failed to fetch asset export status", e);
        }
    }

    private ExportStatus isVulnerabilitiesExported(UUID vulnerabilityExportIdentifier) throws TenableDataImportException {

        Gson gson = Util.getJsonBuilder();
        String vulnerabilityExportStatus = apiMap.get("vulnerabilityExportStatus");
        vulnerabilityExportStatus = vulnerabilityExportStatus.replace("{export_id}", vulnerabilityExportIdentifier.toString());
        String assetExportStatusURL = TENABLE_API_URL + vulnerabilityExportStatus;
        Map<String , String > input = new HashMap<>();
        input.put(Constants.TENABLE_API_KEYS,API_KEYS);
        input.put(Constants.USER_AGENT,USER_AGENT);
        try {
            ExportStatus response = gson.fromJson(HttpUtil.get(assetExportStatusURL, input), ExportStatus.class);
            if (response != null) {
                return response;
            } else {
                throw new TenableDataImportException("Unable to get the  Asset Export Status");
            }
        } catch (UnAuthorisedException | IOException e) {
            throw new TenableDataImportException("Failed to fetch asset export status", e);
        }
    }

    private UUID triggerAssetExport() throws TenableDataImportException {

        Gson gson = Util.getJsonBuilder();
        String assetExport = apiMap.get("assetsExportTrigger");
        String assetExportURL = TENABLE_API_URL + assetExport;
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("chunk_size", 1000);
        jsonObject.put("include_unlicensed", true);
        String requestBody = jsonObject.toString();
        Map<String , String > input = new HashMap<>();
        input.put(Constants.TENABLE_API_KEYS,API_KEYS);
        input.put(Constants.USER_AGENT,USER_AGENT);
        try {
            Map<String, Object> response = ((Map<String, Object>) gson.fromJson(HttpUtil.post(assetExportURL, requestBody, input), Map.class));
            if (response != null) {
                return UUID.fromString(response.get("export_uuid").toString());
            } else
                throw new TenableDataImportException("Unable to trigger Asset Export");
        } catch (UnAuthorisedException | IOException e) {
            throw new TenableDataImportException(e.getMessage());
        }
    }


    private UUID triggerVulnerabilityExport(int days) throws TenableDataImportException {

        Gson gson = Util.getJsonBuilder();
        String vulnerabilityExportTrigger = apiMap.get("vulnerabilityExportTrigger");
        String vulnerabilityExportTriggerURL = TENABLE_API_URL + vulnerabilityExportTrigger;
        JSONObject jsonObject = new JSONObject();
        JSONObject filters = new JSONObject();
        // @TODO we can monitor and tune this
        jsonObject.put("num_assets", assetMap.keySet().size() < 1000 ? assetMap.keySet().size() : 1000);
        filters.put("severity",Arrays.asList("low","medium","high","critical"));
        // @TODO now considering 1 yrs old data we have to make it configurable

        filters.put("since",calculateTimeRange(days));
        jsonObject.put("filters", filters);
        jsonObject.put("include_unlicensed",true);
        String requestBody = jsonObject.toString();

        Map<String , String > input = new HashMap<>();
        input.put(Constants.TENABLE_API_KEYS,API_KEYS);
        input.put(Constants.USER_AGENT,USER_AGENT);
        try {
            Map<String, Object> response = ((Map<String, Object>) gson.fromJson(HttpUtil.post(vulnerabilityExportTriggerURL, requestBody, input), Map.class));
            if (response != null && null!= response.get("export_uuid")) {
                return UUID.fromString(response.get("export_uuid").toString());
            } else
                throw new TenableDataImportException("Unable to trigger vulnerability Export");
        } catch (UnAuthorisedException | IOException e) {
            throw new TenableDataImportException(e.getMessage());
        }
    }

    private long calculateTimeRange(int days) {
        final LocalDate now = LocalDate.now();
        LocalDate yesterday;
        ZonedDateTime startOfDayInZone;
        if(!ElasticSearchManager.indexExists("/"+TENABLE_VM_VULNERABILITY)) {
            return 0;
        }
        else
        {
            yesterday = now.minusDays(days);
            startOfDayInZone = yesterday.atStartOfDay(ZoneId.systemDefault());
        }
        return startOfDayInZone.toEpochSecond();
    }

    private void uploadToES(List<Map<String, Object>> result) throws TenableDataImportException {

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));
        List<Map<String, Object>> vulnDetails = new ArrayList<>();
        try {
            synchronized (vulnDetails) {
                for (Map<String, Object> res : result) {
                    String idValue = buildIDValue(res);
                    res.putIfAbsent("idKey", idValue);
                    vulnDetails.add(res);
                }
            }
            ElasticSearchManager.createIndex(TENABLE_VM_VULNERABILITY);
//            ElasticSearchManager.createType(TENABLE_VM_VULNERABILITY, TYPE);
            ElasticSearchManager.uploadData(TENABLE_VM_VULNERABILITY, TYPE, vulnDetails, DOC_ID);
        }
        catch (Exception e){
            throw new TenableDataImportException("Failed to Upload Tenable VM Vulnerability data to ES",e);
        }
    }

    private String buildIDValue(Map<String, Object> res) {
        Map<String, Object> assetData = (Map<String, Object>) res.get("asset");
        String pluginId = ((Map<String, Object> ) res.get("plugin")).get("id").toString();
        String assetId = (String) assetData.get("uuid");
        return assetId + "-" + pluginId ;
    }
}
