/*******************************************************************************
 * Copyright 2023 Paladin Cloud, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package com.tmobile.cso.pacman.tenable.jobs;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tmobile.cso.pacman.tenable.Constants;
import com.tmobile.cso.pacman.tenable.dto.ExportStatus;
import com.tmobile.cso.pacman.tenable.exception.TenableDataImportException;
import com.tmobile.cso.pacman.tenable.exception.UnAuthorisedException;
import com.tmobile.cso.pacman.tenable.util.ElasticSearchManager;
import com.tmobile.cso.pacman.tenable.util.ErrorManageUtil;
import com.tmobile.cso.pacman.tenable.util.HttpUtil;
import com.tmobile.cso.pacman.tenable.util.Util;
import com.tmobile.pacman.commons.constants.ESIndexConstants;
import net.minidev.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.stream.Collectors;

public class TenableVMVulnerabilityDataImporter extends TenableDataImporter {

    private static TenableVMVulnerabilityDataImporter instance = null;
    private static final Logger log = LoggerFactory.getLogger(TenableVMVulnerabilityDataImporter.class);

    private static final String EXPORT_UUID = "export_uuid";
    private static final int EXPORT_CHECK_RETRY_PERIOD = 120;
    private static final int ASSETS_EXPORT_CHUNK_SIZE = 1000;
    private static final int VULNERABILITY_EXPORT_CHUNK_SIZE = 200;
    private static final String EXPORT_STATUS_MESSAGE_TEMPLATE = "Export Status: %s. Waiting %d more seconds ...";
    private static final String EXPORT_TOOK_TOO_LONG_MESSAGE_TEMPLATE = "Export taking too long, limit %d seconds";
    private static final String INTERRUPTED_MESSAGE_TEMPLATE = "Interrupted {}";
    private static final int MAX_EXPORT_CHECK_RETRY = 30;
    private static final List<Map<String, String>> errorList = new ArrayList<>();
    private static final Map<UUID, String> assetMap = new HashMap<>();

    private TenableVMVulnerabilityDataImporter() {
    }

    public static synchronized TenableVMVulnerabilityDataImporter getInstance() {
        if (instance == null) {
            instance = new TenableVMVulnerabilityDataImporter();
        }

        return instance;
    }

    public Map<String, Object> execute(int days) {
        try {
            loadAssets();
            loadVulnerabilities(days);
        } catch (TenableDataImportException e) {
            log.error("Exception while collecting Tenable Data", e);
            Map<String, String> errorMap = new HashMap<>();
            errorMap.put(Constants.ERROR, "Error in exception while collecting tenable Data");
            errorMap.put(Constants.ERROR_TYPE, Constants.FATAL);
            errorMap.put(Constants.EXCEPTION, e.getMessage());
            errorList.add(errorMap);
        }

        return ErrorManageUtil.formErrorCode(errorList);
    }

    private void loadAssets() throws TenableDataImportException {
        UUID assetExportIdentifier = triggerAssetExport();
        List<Map<String, Object>> assets = checkAndExportAssets(assetExportIdentifier);
        if (!assets.isEmpty()) {
            uploadToES(assets, ESIndexConstants.TENABLE_VM_ASSETS_INDEX_NAME, "asset");
        }
    }

    private void loadVulnerabilities(int days) throws TenableDataImportException {
        UUID vulnerabilityExportIdentifier = triggerVulnerabilityExport(days);
        List<Map<String, Object>> vulnerabilities = checkAndExportVulnerabilities(vulnerabilityExportIdentifier);
        if (!vulnerabilities.isEmpty()) {
            uploadToES(vulnerabilities, ESIndexConstants.TENABLE_VM_VULNERABILITY_INDEX_NAME, "vulnerability");
        }
    }

    private List<Map<String, Object>> checkAndExportAssets(UUID assetExportIdentifier) throws TenableDataImportException {
        boolean exportPending = true;
        ExportStatus exportStatus = null;
        int retryCount = 0;
        while (exportPending) {
            if (retryCount > MAX_EXPORT_CHECK_RETRY) {
                throw new TenableDataImportException(String.format(EXPORT_TOOK_TOO_LONG_MESSAGE_TEMPLATE, (MAX_EXPORT_CHECK_RETRY + 1) * EXPORT_CHECK_RETRY_PERIOD));
            }

            try {
                retryCount++;
                Thread.sleep(EXPORT_CHECK_RETRY_PERIOD * 1000);
            } catch (InterruptedException e) {
                log.error(INTERRUPTED_MESSAGE_TEMPLATE, e);
                Thread.currentThread().interrupt();
                throw new TenableDataImportException("Interrupted while exporting Assets", e);
            }

            exportStatus = getExportStatus(assetExportIdentifier, "assetsExportStatus");
            switch (exportStatus.getStatus()) {
                case "FINISHED":
                    exportPending = false;
                    break;
                case "FAILED":
                    throw new TenableDataImportException("Asset Export Failed");
                case "CANCELLED":
                    throw new TenableDataImportException("Asset Export Cancelled");
                default:
                    log.info(String.format(EXPORT_STATUS_MESSAGE_TEMPLATE,
                            exportStatus.getStatus(),
                            EXPORT_CHECK_RETRY_PERIOD));
                    break;
            }
        }

        log.info("Asset Export Completed");
        log.info("Chunks Produced (each chunk up to {} items): {}", ASSETS_EXPORT_CHUNK_SIZE, exportStatus.getChunkIds().size());
        List<Map<String, Object>> assets = exportAssets(assetExportIdentifier, exportStatus);
        log.info("Total Assets Exported: {}", assets.size());
        return assets;
    }

    private List<Map<String, Object>> checkAndExportVulnerabilities(UUID vulnerabilityExportIdentifier) throws TenableDataImportException {
        boolean exportPending = true;
        ExportStatus exportStatus = null;
        int retryCount = 0;
        while (exportPending) {
            if (retryCount > MAX_EXPORT_CHECK_RETRY) {
                throw new TenableDataImportException(String.format(EXPORT_TOOK_TOO_LONG_MESSAGE_TEMPLATE, (MAX_EXPORT_CHECK_RETRY + 1) * EXPORT_CHECK_RETRY_PERIOD));
            }

            try {
                retryCount++;
                Thread.sleep(EXPORT_CHECK_RETRY_PERIOD * 1000);
            } catch (InterruptedException e) {
                log.error(INTERRUPTED_MESSAGE_TEMPLATE, e);
                Thread.currentThread().interrupt();
                throw new TenableDataImportException("Interrupted while exporting Vulnerabilities", e);
            }

            exportStatus = getExportStatus(vulnerabilityExportIdentifier, "vulnerabilityExportStatus");
            switch (exportStatus.getStatus()) {
                case "FINISHED":
                    exportPending = false;
                    break;
                case "FAILED":
                    throw new TenableDataImportException("Vulnerability Export Failed");
                case "CANCELLED":
                    throw new TenableDataImportException("Vulnerability Export Cancelled");
                default:
                    log.info(String.format(EXPORT_STATUS_MESSAGE_TEMPLATE,
                            exportStatus.getStatus(),
                            EXPORT_CHECK_RETRY_PERIOD));
                    break;
            }
        }

        log.info("Vulnerability Export Completed");
        log.info("Chunks Produced: {}", exportStatus.getChunkIds().size());
        List<Map<String, Object>> vulnerabilities = exportVulnerabilities(vulnerabilityExportIdentifier, exportStatus);
        log.info("Total Vulnerabilities Exported: {}", vulnerabilities.size());
        return vulnerabilities;
    }

    private List<Map<String, Object>> exportAssets(UUID exportId, ExportStatus exportStatus) throws TenableDataImportException {
        List<Map<String, Object>> result = new ArrayList<>();
        if (exportStatus != null) {
            for (Integer chunkId : exportStatus.getChunkIds()) {
                log.info("Exporting Assets Chunk -> {}", chunkId);
                Map<String, String> params = new HashMap<String, String>() {{
                    put("export_id", exportId.toString());
                    put("chunk_id", chunkId.toString());
                }};
                String assetExportApiUrl = getTenableApiUrl("assetsExport", params);
                try {
                    Map<String, String> input = getBaseTenableInput();
                    String response = HttpUtil.get(assetExportApiUrl, input);
                    List<Map<String, Object>> parsedResponse = (List<Map<String, Object>>) Util.getJsonBuilder().fromJson(response, List.class);
                    log.info("Exported Assets Chunk -> Id:{}, Size:{}", chunkId, parsedResponse.size());
                    if (!parsedResponse.isEmpty()) {
                        List<Map<String, Object>> filteredResponse = parsedResponse
                                .stream()
                                .filter(asset -> asset.get("aws_ec2_instance_id") != null)
                                .collect(Collectors.toList());
                        assetMap.putAll(
                                filteredResponse
                                        .stream()
                                        .collect(Collectors.toMap(
                                                asset -> UUID.fromString(asset.get("id").toString()),
                                                asset -> asset.get("aws_ec2_instance_id").toString())));
                        result.addAll(filteredResponse);
                    } else {
                        throw new TenableDataImportException("Unable to exports Assets");
                    }
                } catch (IOException | UnAuthorisedException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            throw new TenableDataImportException("Unable to exports Assets");
        }

        return result;
    }

    private List<Map<String, Object>> exportVulnerabilities(UUID exportId, ExportStatus exportStatus) throws TenableDataImportException {
        List<Map<String, Object>> response = new ArrayList<>();
        if (exportStatus != null) {
            for (Integer chunkId : exportStatus.getChunkIds()) {
                log.info("Exporting Vulnerabilities Chunk -> {}", chunkId);
                Map<String, String> params = new HashMap<String, String>() {{
                    put("export_id", exportId.toString());
                    put("chunk_id", chunkId.toString());
                }};
                String vulnerabilityExportApiUrl = getTenableApiUrl("vulnerabilityExport", params);
                Map<String, String> input = getBaseTenableInput();
                try {
                    String responseString = HttpUtil.get(vulnerabilityExportApiUrl, input);
                    List<Map<String, Object>> parsedResponse = (List<Map<String, Object>>) Util.getJsonBuilder().fromJson(responseString, List.class);
                    log.info("Exported Vulnerabilities Chunk -> Id:{}, Size:{}", chunkId, parsedResponse.size());
                    if (!parsedResponse.isEmpty()) {
                        parsedResponse.stream()
                                .forEach(vulnerability ->
                                        ((Map<String, Object>) vulnerability.get("asset"))
                                                .put("instanceId", assetMap.get(UUID.fromString(((Map<String, Object>) vulnerability.get("asset")).get("uuid").toString()))));
                        response.addAll(parsedResponse);
                    } else {
                        throw new TenableDataImportException("Unable to exports Vulnerabilities");
                    }
                } catch (IOException | UnAuthorisedException e) {
                    throw new RuntimeException(e);
                }
            }
        } else {
            throw new TenableDataImportException("Unable to exports Vulnerabilities");
        }

        return response;
    }

    private ExportStatus getExportStatus(UUID exportId, String apiMapKey) throws TenableDataImportException {
        try {
            Map<String, String> params = new HashMap<String, String>() {{
                put("export_id", exportId.toString());
            }};
            String exportStatusApiUrl = getTenableApiUrl(apiMapKey, params);
            Map<String, String> input = getBaseTenableInput();
            ExportStatus response = Util.getJsonBuilder().fromJson(HttpUtil.get(exportStatusApiUrl, input), ExportStatus.class);
            if (response != null) {
                return response;
            } else {
                throw new TenableDataImportException("Unable to get the Export Status from " + exportStatusApiUrl);
            }
        } catch (UnAuthorisedException | IOException e) {
            throw new TenableDataImportException("Failed to fetch export status", e);
        }
    }

    private UUID triggerAssetExport() throws TenableDataImportException {
        // TODO: Per Tenable, need to limit asset data we collect to new data appeared since last scan.
        JSONObject filters = new JSONObject();
        filters.put("is_terminated", false);
        filters.put("last_authenticated_scan_time", 0);

        JSONObject jsonObject = new JSONObject();
        jsonObject.put("chunk_size", ASSETS_EXPORT_CHUNK_SIZE);
        jsonObject.put("include_unlicensed", true);
        jsonObject.put("filters", filters);
        String requestBody = jsonObject.toString();

        return triggerExport(requestBody, "assetsExportTrigger");
    }

    private UUID triggerVulnerabilityExport(int days) throws TenableDataImportException {
        JSONObject filters = new JSONObject();
        filters.put("severity", Arrays.asList("low", "medium", "high", "critical"));
        // TODO now considering 1 yrs old data we have to make it configurable
        filters.put("since", calculateTimeRange(days));
        filters.put("state", Arrays.asList("REOPENED", "OPEN"));
        filters.put("plugin_type", "local");

        JSONObject jsonObject = new JSONObject();
        // TODO we can monitor and tune this
        jsonObject.put("num_assets", VULNERABILITY_EXPORT_CHUNK_SIZE);
        jsonObject.put("filters", filters);
        jsonObject.put("include_unlicensed", true);
        String requestBody = jsonObject.toString();

        return triggerExport(requestBody, "vulnerabilityExportTrigger");
    }

    private UUID triggerExport(String requestBody, String apiKey) throws TenableDataImportException {
        Map<String, String> input = getBaseTenableInput();
        try {
            String exportApiUrl = getTenableApiUrl(apiKey, null);
            String response = HttpUtil.post(exportApiUrl, requestBody, input);
            Map<String, Object> parsedResponse = ((Map<String, Object>) Util.getJsonBuilder().fromJson(response, Map.class));
            if (parsedResponse != null && parsedResponse.get(EXPORT_UUID) != null) {
                return UUID.fromString(parsedResponse.get(EXPORT_UUID).toString());
            } else {
                String errorMessage = "Unable to trigger Export. Status: "
                        + parsedResponse.getOrDefault("status", "UNKNOWN")
                        + ", Message: "
                        + parsedResponse.getOrDefault("message", "UNKNOWN");
                throw new TenableDataImportException(errorMessage);
            }
        } catch (UnAuthorisedException e) {
            log.info("Exception while triggering Export -> {}", e.toString());
            throw new TenableDataImportException("UnAuthorisedException: " + e.getMessage());
        } catch (Exception e) {
            log.info("Exception while triggering Export -> {}", e.toString());
            throw new TenableDataImportException("Exception: " + e.getMessage());
        }
    }

    private Map<String, String> getBaseTenableInput() {
        Map<String, String> input = new HashMap<>();
        input.put(Constants.X_API_KEYS_HEADER_NAME, apiKeys);
        input.put(Constants.USER_AGENT_HEADER_NAME, userAgent);
        return input;
    }

    private long calculateTimeRange(int days) {
        final LocalDate now = LocalDate.now();
        LocalDate yesterday;
        ZonedDateTime startOfDayInZone;
        if (!ElasticSearchManager.indexExists(ESIndexConstants.TENABLE_VM_VULNERABILITY_INDEX_NAME)) {
            return 0;
        } else {
            yesterday = now.minusDays(days);
            startOfDayInZone = yesterday.atStartOfDay(ZoneId.systemDefault());
        }

        return startOfDayInZone.toEpochSecond();
    }

    private void uploadToES(List<Map<String, Object>> result, String indexName, String dataType) throws TenableDataImportException {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd"));

            List<Map<String, Object>> details = new ArrayList<>();
            synchronized (Collections.unmodifiableList(details)) {
                for (Map<String, Object> res : result) {
                    String idValue = dataType == "vulnerability" ? buildIDValue(res) : res.get("id").toString();
                    res.putIfAbsent("idKey", idValue);
                    details.add(res);
                }
            }

            log.info("Total " + dataType + " to be uploaded: {}", details.size());
            ElasticSearchManager.createIndex(indexName);
            ElasticSearchManager.uploadData(indexName, dataType, details, "idKey");
        } catch (Exception e) {
            throw new TenableDataImportException("Failed to Upload Tenable VM " + dataType + " data to ES", e);
        }
    }

    private String buildIDValue(Map<String, Object> res) {
        Map<String, Object> assetData = (Map<String, Object>) res.get("asset");
        String pluginId = ((Map<String, Object>) res.get("plugin")).get("id").toString();
        String assetId = (String) assetData.get("uuid");
        return assetId + "-" + pluginId;
    }

    private String getTenableApiUrl(String apiPathKey, Map<String, String> params) {
        String apiPath = apiMap.get(apiPathKey);
        if (params != null && !params.isEmpty()) {
            for (Map.Entry<String, String> entry : params.entrySet()) {
                apiPath = apiPath.replace("{" + entry.getKey() + "}", entry.getValue());
            }
        }
        return tenableApiUrl + apiPath;
    }
}
