/*******************************************************************************
 *  Copyright 2023 Paladin Cloud, Inc. or its affiliates. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not
 *  use this file except in compliance with the License.  You may obtain a copy
 *  of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 *  License for the specific language governing permissions and limitations under
 *  the License.
 ******************************************************************************/
package com.tmobile.cloud.contrastrules.library;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nimbusds.oauth2.sdk.util.MapUtils;
import com.tmobile.cloud.awsrules.utils.PacmanUtils;
import com.tmobile.cloud.constants.PacmanRuleConstants;
import com.tmobile.cloud.contrastrules.utils.ResourceVulnerability;
import com.tmobile.cloud.model.CveDetails;
import com.tmobile.cloud.model.VulnerabilityInfo;
import com.tmobile.pacman.commons.PacmanSdkConstants;
import com.tmobile.pacman.commons.exception.InvalidInputException;
import com.tmobile.pacman.commons.policy.Annotation;
import com.tmobile.pacman.commons.policy.BasePolicy;
import com.tmobile.pacman.commons.policy.PacmanPolicy;
import com.tmobile.pacman.commons.policy.PolicyResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;


@PacmanPolicy(key = "check-vulnerability-exists-for-library", desc = "Checks for the presence of vulnerabilities.", severity = PacmanSdkConstants.SEV_HIGH, category = PacmanSdkConstants.SECURITY)
public class LibraryVulnerabilityAssessmentPolicy extends BasePolicy {

    private static final Logger logger = LoggerFactory.getLogger(LibraryVulnerabilityAssessmentPolicy.class);

    private static final String CONTRAST_URL_TEMPLATE = "https://eval.contrastsecurity.com/Contrast/static/ng/" +
            "index.html#/%s/libraries?quickFilter=VULNERABLE&filterText=%s";

    /**
     * @param policyParam        parameters for policy validation
     * @param resourceAttributes this is a resource in context which needs to be scanned this is provided by execution engine
     */
    @Override
    public PolicyResult execute(final Map<String, String> policyParam, Map<String, String> resourceAttributes) {
        logger.debug("LibraryVulnerabilityAssessmentPolicy started");
        if (MapUtils.isNotEmpty(policyParam) && !PacmanUtils.doesAllHaveValue(policyParam.get(PacmanRuleConstants.SEVERITY),
                policyParam.get(PacmanRuleConstants.CATEGORY))) {
            logger.info(PacmanRuleConstants.MISSING_CONFIGURATION);
            throw new InvalidInputException(PacmanRuleConstants.MISSING_CONFIGURATION);
        }
        String policyId = policyParam.get(PacmanSdkConstants.POLICY_ID);
        String accountId = resourceAttributes.get(PacmanRuleConstants.ACCOUNTID);
        MDC.put("executionId", policyParam.get("executionId"));
        MDC.put("policyId", policyId);
        String vulnerabilities;
        String severity = policyParam.get("severityToCheck");
        List<VulnerabilityInfo> vulnerabilityDetailsList = new ArrayList<>();
        ObjectMapper mapper = new ObjectMapper();
        try {
            vulnerabilities = resourceAttributes.get("vulns");
            if (vulnerabilities == null || vulnerabilities.isEmpty()) {
                return new PolicyResult(PacmanSdkConstants.STATUS_SUCCESS, PacmanRuleConstants.SUCCESS_MESSAGE);
            }
            ResourceVulnerability[] vulnerabilityList = mapper.readValue(vulnerabilities,
                    new TypeReference<ResourceVulnerability[]>() {
                    });
            List<ResourceVulnerability> filteredList = Arrays.stream(vulnerabilityList).filter(vuln -> vuln.getSeverityToUse()
                    .equalsIgnoreCase(severity)).collect(Collectors.toList());
            if (filteredList.isEmpty()) {
                return new PolicyResult(PacmanSdkConstants.STATUS_SUCCESS, PacmanRuleConstants.SUCCESS_MESSAGE);
            }
            String vulnerabilityUrl = String.format(CONTRAST_URL_TEMPLATE, accountId,
                    resourceAttributes.get("fileName"));
            filteredList.forEach(vul -> {
                List<CveDetails> cveList = new ArrayList<>();
                VulnerabilityInfo vulnerability = new VulnerabilityInfo();
                vulnerability.setVulnerabilityUrl(vulnerabilityUrl);
                vulnerability.setTitle(vul.getDescription().replace("\u00a0",""));
                CveDetails cve = new CveDetails();
                cve.setId(vul.getName());
                cve.setUrl(PacmanUtils.NIST_VULN_DETAILS_URL + vul.getName());
                cveList.add(cve);
                vulnerability.setCveList(cveList);
                vulnerabilityDetailsList.add(vulnerability);
            });
            return buildFailureAnnotation(policyParam, vulnerabilityDetailsList,
                    resourceAttributes);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            return buildFailureAnnotation(policyParam, vulnerabilityDetailsList, resourceAttributes);
        }
    }

    @Override
    public String getHelpText() {
        return "Checks for the presence of vulnerabilities.";
    }

    private PolicyResult buildFailureAnnotation(final Map<String, String> policyParam,
                                                List<VulnerabilityInfo> vulnerabilityDetailsList,
                                                Map<String, String> resourceAttributes) {
        ObjectMapper mapper = new ObjectMapper();
        String violationDetails = "";
        String fileName = resourceAttributes.get("fileName");
        try {
            violationDetails = mapper.writeValueAsString(vulnerabilityDetailsList);
        } catch (Exception e) {
            logger.error("error while converting violation details for {}", fileName);
        }
        String policyId = policyParam.get(PacmanSdkConstants.POLICY_ID);
        String desc = String.format("%s has %d vulnerabilities", fileName, vulnerabilityDetailsList.size());
        LinkedHashMap<String, Object> issue = new LinkedHashMap<>();
        List<LinkedHashMap<String, Object>> issueList = new ArrayList<>();
        Annotation annotation = Annotation.buildAnnotation(policyParam, Annotation.Type.ISSUE);
        annotation.put(PacmanSdkConstants.DESCRIPTION, desc);
        annotation.put(PacmanRuleConstants.SEVERITY, policyParam.get(PacmanRuleConstants.SEVERITY));
        annotation.put(PacmanRuleConstants.CATEGORY, policyParam.get(PacmanRuleConstants.CATEGORY));
        annotation.put(PacmanRuleConstants.RESOURCE_ID, policyParam.get(PacmanRuleConstants.RESOURCE_ID));
        issue.put(PacmanRuleConstants.VIOLATION_REASON, desc);
        annotation.put("vulnerabilityDetails", violationDetails);
        issueList.add(issue);
        annotation.put("issueDetails", issueList.toString());
        logger.debug("Failure annotation {} created for policy with policy key {}", annotation, policyId);
        return new PolicyResult(PacmanSdkConstants.STATUS_FAILURE, PacmanRuleConstants.FAILURE_MESSAGE, annotation);
    }
}
