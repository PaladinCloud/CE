package com.tmobile.cloud.crowdstrike;

import com.amazonaws.util.StringUtils;
import com.google.gson.JsonArray;
import com.nimbusds.oauth2.sdk.util.MapUtils;
import com.tmobile.cloud.awsrules.utils.PacmanUtils;
import com.tmobile.cloud.constants.PacmanRuleConstants;
import com.tmobile.pacman.commons.PacmanSdkConstants;
import com.tmobile.pacman.commons.exception.InvalidInputException;
import com.tmobile.pacman.commons.exception.RuleExecutionFailedExeption;
import com.tmobile.pacman.commons.policy.Annotation;
import com.tmobile.pacman.commons.policy.BasePolicy;
import com.tmobile.pacman.commons.policy.PacmanPolicy;
import com.tmobile.pacman.commons.policy.PolicyResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@PacmanPolicy(key = "check-vulnerability-exists-for-server", desc = "Checks for the presence of vulnerabilities.", severity = PacmanSdkConstants.SEV_HIGH, category = PacmanSdkConstants.SECURITY)
public class VulnerabilityAssessmentPolicy extends BasePolicy {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityAssessmentPolicy.class);

    public PolicyResult execute(final Map<String, String> policyParam, Map<String, String> resourceAttributes) {
        logger.debug("Server vulnerability assessment policy started for resource {}", resourceAttributes.get("_resourceid"));
        Annotation annotation = null;
        String instanceId = null;

        String severity = policyParam.get(PacmanRuleConstants.SEVERITY);
        String severityToCheck = policyParam.get(PacmanRuleConstants.SEVERITY_TO_CHECK);
        String category = policyParam.get(PacmanRuleConstants.CATEGORY);

        if (MapUtils.isEmpty(policyParam) || MapUtils.isEmpty(resourceAttributes)
                || !PacmanUtils.doesAllHaveValue(severity, category)) {
            logger.info(PacmanRuleConstants.MISSING_CONFIGURATION);
            throw new InvalidInputException(PacmanRuleConstants.MISSING_CONFIGURATION);
        }

        String esIndexUrl = PacmanUtils.formatUrl(policyParam, PacmanRuleConstants.ES_RESOURCE_WITH_VULN_INFO_SEVERITY_URL);
        MDC.put("executionId", policyParam.get("executionId"));
        MDC.put("ruleId", policyParam.get(PacmanSdkConstants.POLICY_ID));

        List<LinkedHashMap<String, Object>> issueList = new ArrayList<>();
        LinkedHashMap<String, Object> issue = new LinkedHashMap<>();
        if (resourceAttributes != null) {
            instanceId = StringUtils.trim(resourceAttributes.get(PacmanRuleConstants.INSTANCEID));
            try {
                JsonArray severityList = PacmanUtils.getVulnerabilitiesArray(severityToCheck, instanceId, esIndexUrl);
                if (severityList != null && !severityList.isEmpty()) {
                    String severityDetails = PacmanUtils.getVulnerabilitiesDetails(severityList);
                    annotation = Annotation.buildAnnotation(policyParam, Annotation.Type.ISSUE);
                    annotation.put(PacmanSdkConstants.DESCRIPTION, "An Ec2 instance with " + severity + " vulnerability found!!");
                    annotation.put(PacmanRuleConstants.SEVERITY, severity);
                    annotation.put(PacmanRuleConstants.CATEGORY, category);
                    annotation.put("vulnerabilityDetails", severityDetails);
                    issue.put(PacmanRuleConstants.VIOLATION_REASON, "An Ec2 instance with " + severity + " vulnerability found!!");
                    issueList.add(issue);
                    annotation.put("issueDetails", issueList.toString());

                    logger.debug("========Server vulnerability assessment policy for resource {} ended with an annotation {} : =========", resourceAttributes.get("_resourceid"), annotation);
                    return new PolicyResult(PacmanSdkConstants.STATUS_FAILURE, PacmanRuleConstants.FAILURE_MESSAGE, annotation);

                }
            } catch (Exception e) {
                logger.error("Error evaluating Server vulnerability assessment policy for resource " + resourceAttributes.get("_resourceid"), e);
                throw new RuleExecutionFailedExeption(e.getMessage());
            }

        }
        logger.debug("Server vulnerability assessment policy evaluation successful for resource {}", resourceAttributes.get("_resourceid"));
        return new PolicyResult(PacmanSdkConstants.STATUS_SUCCESS, PacmanRuleConstants.SUCCESS_MESSAGE);
    }

    @Override
    public String getHelpText() {
        return "Checks for the presence of vulnerabilities in servers.";
    }
}
