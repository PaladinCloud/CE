/*******************************************************************************
 * Copyright 2023 Paladin Cloud, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package com.tmobile.cloud.awsrules.ec2;

import com.amazonaws.util.CollectionUtils;
import com.amazonaws.util.StringUtils;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.tmobile.cloud.awsrules.ec2.model.CveDetails;
import com.tmobile.cloud.awsrules.ec2.model.VulnerabilityInfo;
import com.tmobile.cloud.awsrules.utils.PacmanUtils;
import com.tmobile.cloud.constants.PacmanRuleConstants;
import com.tmobile.pacman.commons.PacmanSdkConstants;
import com.tmobile.pacman.commons.exception.InvalidInputException;
import com.tmobile.pacman.commons.exception.RuleExecutionFailedExeption;
import com.tmobile.pacman.commons.policy.Annotation;
import com.tmobile.pacman.commons.policy.BasePolicy;
import com.tmobile.pacman.commons.policy.PacmanPolicy;
import com.tmobile.pacman.commons.policy.PolicyResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import java.util.*;

@PacmanPolicy(key = "check-for-vm-vulnerabilities-scanned-by-tenable", desc = "checks for VMs scanned by tenable,and report if vulnerability criteria met", severity = PacmanSdkConstants.SEV_HIGH, category = PacmanSdkConstants.GOVERNANCE)
public class VMsWithSeverityVulnerabilityRule extends BasePolicy {

    private final String DESCRIPTION_JSON_FIELD = "description";
    private final String SOLUTION_JSON_FIELD = "solution";
    private static final Logger logger = LoggerFactory.getLogger(VMsWithSeverityVulnerabilityRule.class);

    /**
     * The method will get triggered from Rule Engine with following parameters.
     *
     * @param ruleParam          ************* Following are the Rule Parameters********* <br><br>
     *                           <p>
     *                           ruleKey : check-for-vm-vulnerabilities-scanned-by-tenable <br><br>
     *                           <p>
     *                           target : Enter the target days <br><br>
     *                           <p>
     *                           discoveredDaysRange : Enter the discovered days Range <br><br>
     *                           <p>
     *                           esTenableUrl : Enter the Tenable URL <br><br>
     * @param resourceAttributes this is a resource in context which needs to be scanned this is provided by execution engine
     * @return the rule result
     */
    @Override
    public PolicyResult execute(Map<String, String> ruleParam, Map<String, String> resourceAttributes) {
        logger.debug("Policy started");
        MDC.put("executionId", ruleParam.get("executionId")); // this is the logback Mapped Diagnostic Contex
        MDC.put("ruleId", ruleParam.get(PacmanSdkConstants.POLICY_ID)); // this is the logback Mapped Diagnostic Contex

        String category = ruleParam.get(PacmanRuleConstants.CATEGORY);
        String severity = ruleParam.get(PacmanRuleConstants.SEVERITY);
        String discoveredDaysRange = ruleParam.get(PacmanRuleConstants.DISCOVERED_DAYS_RANGE);
        String tenableESAPI = PacmanUtils.formatUrl(ruleParam, PacmanRuleConstants.ES_TENABLE_IMAGE_URL);

        if (!PacmanUtils.doesAllHaveValue(category, tenableESAPI, discoveredDaysRange, severity)) {
            logger.info(PacmanRuleConstants.MISSING_CONFIGURATION);
            throw new InvalidInputException(PacmanRuleConstants.MISSING_CONFIGURATION);
        }

        if (resourceAttributes != null) {
            String instanceId = StringUtils.trim(resourceAttributes.get(PacmanRuleConstants.RESOURCE_ID));
            List<JsonObject> vulnerabilityInfoList;
            try {
                vulnerabilityInfoList = PacmanUtils.checkInstanceIdFromElasticSearchForTenable(instanceId, tenableESAPI, "asset.instanceId", severity);
            } catch (Exception e) {
                logger.error("unable to determine", e);
                throw new RuleExecutionFailedExeption("unable to determine" + e);
            }

            if (!CollectionUtils.isNullOrEmpty(vulnerabilityInfoList)) {
                JsonObject firstVulnerability = vulnerabilityInfoList.get(0);
                Map<String, Object> issueDetails = buildVMIssueDetails(firstVulnerability);
                fillMoreInfo(vulnerabilityInfoList, issueDetails);
                JsonObject pluginDetails = firstVulnerability.get("plugin").getAsJsonObject();

                Annotation annotation = Annotation.buildAnnotation(ruleParam, Annotation.Type.ISSUE);
                annotation.put(PacmanSdkConstants.DESCRIPTION, pluginDetails.get(DESCRIPTION_JSON_FIELD).getAsString());
                annotation.put(PacmanRuleConstants.SEVERITY, severity);
                annotation.put(PacmanRuleConstants.CATEGORY, category);
                annotation.put("issueDetails", Arrays.asList(issueDetails).toString());

                String vulnerabilityDetails = getVMVulnerabilityDetails(vulnerabilityInfoList);
                annotation.put("vulnerabilityDetails", vulnerabilityDetails);

                return new PolicyResult(PacmanSdkConstants.STATUS_FAILURE, PacmanRuleConstants.FAILURE_MESSAGE, annotation);
            }
        }

        logger.debug("Policy ended");

        return new PolicyResult(PacmanSdkConstants.STATUS_SUCCESS, PacmanRuleConstants.SUCCESS_MESSAGE);
    }

    private String getVMVulnerabilityDetails(List<JsonObject> vulnerabilityInfoList) {
        List<VulnerabilityInfo> vulnerabilityList = new ArrayList<>();
        for (JsonObject vulnerability : vulnerabilityInfoList) {
            JsonObject pluginDetails = vulnerability.get("plugin").getAsJsonObject();
            JsonElement cveDetails = pluginDetails.get("cve");
            if (null != cveDetails && !cveDetails.getAsJsonArray().isEmpty()) {
                List<CveDetails> cveList = new ArrayList<>();
                VulnerabilityInfo vul = new VulnerabilityInfo();
                vul.setTitle(pluginDetails.get("name").getAsString());
                Long assetId = pluginDetails.get("id").getAsLong();
                vul.setVulnerabilityUrl("https://cloud.tenable.com/tio/app.html#/vulnerability-management/dashboard/vulnerabilities/by-plugins/vulnerability-details/" + assetId + "/assets-affected");
                for (JsonElement elem : cveDetails.getAsJsonArray()) {
                    String id = elem.getAsString();
                    CveDetails cve = new CveDetails(id, "https://www.tenable.com/cve/" + id);
                    cveList.add(cve);
                }

                vul.setCveList(cveList);
                vulnerabilityList.add(vul);
            }
        }

        ObjectMapper objectMapper = new ObjectMapper();
        try {
            return objectMapper.writeValueAsString(vulnerabilityList);
        } catch (JsonProcessingException e) {
            throw new RuleExecutionFailedExeption(e.getMessage());
        }
    }

    private void fillMoreInfo(List<JsonObject> vulnerabilityInfoList, Map<String, Object> issueDetails) {
        String moreInfo = "";
        for (JsonObject vulnerability : vulnerabilityInfoList) {
            JsonObject pluginDetails = vulnerability.get("plugin").getAsJsonObject();
            if (!pluginDetails.has("see_also") || pluginDetails.get("see_also").isJsonNull()){
                continue;
            }

            JsonArray seeAlsoList = pluginDetails.get("see_also").getAsJsonArray();
            for (JsonElement elem : seeAlsoList) {
                moreInfo = moreInfo.concat(elem.getAsString() + " ");
            }
        }

        issueDetails.put(PacmanRuleConstants.TENABLE_MORE_INFO, moreInfo);
    }

    private Map<String, Object> buildVMIssueDetails(JsonObject vulnerability) {
        JsonObject pluginDetails = vulnerability.get("plugin").getAsJsonObject();
        JsonObject assetDetails = vulnerability.get("asset").getAsJsonObject();

        Map<String, Object> issueDetails = new HashMap<>();
        if (pluginDetails.has(DESCRIPTION_JSON_FIELD)){
            issueDetails.put(PacmanRuleConstants.VIOLATION_REASON, formatString(pluginDetails.get(DESCRIPTION_JSON_FIELD)));
        }

        if (pluginDetails.has(SOLUTION_JSON_FIELD)){
            issueDetails.put(PacmanRuleConstants.TENABLE_SOLUTION, formatString(pluginDetails.get(SOLUTION_JSON_FIELD)));
        }

        issueDetails.put(PacmanRuleConstants.SEVERITY, vulnerability.get(PacmanRuleConstants.SEVERITY).getAsString());
        issueDetails.put(PacmanRuleConstants.HOST_NAME, assetDetails.get("instanceId"));

        return issueDetails;
    }

    private String formatString(JsonElement element) {
        return element.isJsonNull() || element.getAsString().isEmpty() ? "Not Provided" : element.getAsString().replaceAll(", ", ",");
    }

    @Override
    public String getHelpText() {
        return null;
    }
}
