package com.tmobile.cloud.awsrules.ec2;


import com.amazonaws.util.CollectionUtils;
import com.amazonaws.util.StringUtils;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.tmobile.cloud.awsrules.ec2.model.CveDetails;
import com.tmobile.cloud.awsrules.ec2.model.VulnerabilityInfo;
import com.tmobile.cloud.awsrules.utils.PacmanUtils;
import com.tmobile.cloud.constants.PacmanRuleConstants;
import com.tmobile.pacman.commons.PacmanSdkConstants;
import com.tmobile.pacman.commons.exception.InvalidInputException;
import com.tmobile.pacman.commons.exception.RuleExecutionFailedExeption;
import com.tmobile.pacman.commons.policy.Annotation;
import com.tmobile.pacman.commons.policy.BasePolicy;
import com.tmobile.pacman.commons.policy.PacmanPolicy;
import com.tmobile.pacman.commons.policy.PolicyResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import java.util.*;

@PacmanPolicy(key = "check-for-vm-vulnerabilities-scanned-by-tenable", desc = "checks for VMs scanned by tenable,and report if vulnerability criteria met", severity = PacmanSdkConstants.SEV_HIGH, category = PacmanSdkConstants.GOVERNANCE)
public class VMsWithSeverityVulnerabilityRule extends BasePolicy {

  private static final Logger logger = LoggerFactory.getLogger(VMsWithSeverityVulnerabilityRule.class);

  /**
   * The method will get triggered from Rule Engine with following parameters.
   *
   * @param ruleParam          ************* Following are the Rule Parameters********* <br><br>
   *                           <p>
   *                           ruleKey : check-for-vm-vulnerabilities-scanned-by-tenable <br><br>
   *                           <p>
   *                           target : Enter the target days <br><br>
   *                           <p>
   *                           discoveredDaysRange : Enter the discovered days Range <br><br>
   *                           <p>
   *                           esTenableUrl : Enter the Tenable URL <br><br>
   * @param resourceAttributes this is a resource in context which needs to be scanned this is provided by execution engine
   * @return the rule result
   */

  @Override
  public PolicyResult execute(Map<String, String> ruleParam, Map<String, String> resourceAttributes) {
    logger.debug("VMsWithSeverityVulnerabilityRule execution started .............");
    Annotation annotation = null;
    String instanceId = null;
    String category = ruleParam.get(PacmanRuleConstants.CATEGORY);
    String severity = ruleParam.get(PacmanRuleConstants.SEVERITY);
    String discoveredDaysRange = ruleParam.get(PacmanRuleConstants.DISCOVERED_DAYS_RANGE);

    String tenableESAPI = null;
    String formattedUrl = PacmanUtils.formatUrl(ruleParam, PacmanRuleConstants.ES_TENABLE_IMAGE_URL);
    if (!StringUtils.isNullOrEmpty(formattedUrl)) {
        tenableESAPI = formattedUrl;
    }
    MDC.put("executionId", ruleParam.get("executionId")); // this is the logback Mapped Diagnostic Contex
    MDC.put("ruleId", ruleParam.get(PacmanSdkConstants.POLICY_ID)); // this is the logback Mapped Diagnostic Contex
    if (!PacmanUtils.doesAllHaveValue( category, tenableESAPI,  discoveredDaysRange)) {
      logger.info(PacmanRuleConstants.MISSING_CONFIGURATION);
      throw new InvalidInputException(PacmanRuleConstants.MISSING_CONFIGURATION);
    }
    if (resourceAttributes != null) {
      instanceId = StringUtils.trim(resourceAttributes.get(PacmanRuleConstants.RESOURCE_ID));
        List<JsonObject> vulnerabilityInfoList = new ArrayList<>();
      try {
        vulnerabilityInfoList = PacmanUtils.checkInstanceIdFromElasticSearchForTenable(instanceId, tenableESAPI, "asset.instanceId", severity);
      } catch (Exception e) {
        logger.error("unable to determine", e);
        throw new RuleExecutionFailedExeption("unable to determine" + e);
      }
      if (!CollectionUtils.isNullOrEmpty(vulnerabilityInfoList)) {
          JsonObject firstVulnerability = vulnerabilityInfoList.get(0);
          List<Map<String, Object>> issueDetails = buildVMIssueDetails(firstVulnerability);
          getMoreInfo(vulnerabilityInfoList,issueDetails);
          String vulnerabilityDetails = getVMVulnerabilityDetails(vulnerabilityInfoList);
          annotation = Annotation.buildAnnotation(ruleParam, Annotation.Type.ISSUE);
          if (issueDetails != null) {
              JsonObject pluginDetails = firstVulnerability.get("plugin").getAsJsonObject();
              annotation.put(PacmanSdkConstants.DESCRIPTION, pluginDetails.get("description").getAsString());
              annotation.put(PacmanRuleConstants.SEVERITY, severity);
              annotation.put(PacmanRuleConstants.CATEGORY, category);
              annotation.put("issueDetails", issueDetails.toString());
              annotation.put("vulnerabilityDetails", vulnerabilityDetails);
              return new PolicyResult(PacmanSdkConstants.STATUS_FAILURE, PacmanRuleConstants.FAILURE_MESSAGE, annotation);

          }
      }
    }
    logger.debug("========VMsWithSeverityVulnerabilityRule ended=========");
    return new PolicyResult(PacmanSdkConstants.STATUS_SUCCESS, PacmanRuleConstants.SUCCESS_MESSAGE);
  }

    private String getVMVulnerabilityDetails(List<JsonObject> vulnerabilityInfoList) {

        List<VulnerabilityInfo> vulnerabilityList=new ArrayList<>();
        for(JsonObject vulnerability  : vulnerabilityInfoList){
            VulnerabilityInfo vul = new VulnerabilityInfo();
            JsonObject pluginDetails = vulnerability.get("plugin").getAsJsonObject();
            JsonElement cveDetails = pluginDetails.get("cve");
            if(null!=cveDetails && !cveDetails.getAsJsonArray().isEmpty()){
                List<CveDetails> cveList = new ArrayList<>();
                vul.setTitle(pluginDetails.get("name").getAsString());
                for(JsonElement elem : cveDetails.getAsJsonArray()){
                    String id = elem.getAsString();
                    CveDetails cve = new CveDetails(id,null);
                    cveList.add(cve);
                }
                vul.setCveList(cveList);
                vulnerabilityList.add(vul);
            }
        }
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            return objectMapper.writeValueAsString(vulnerabilityList);
        } catch (JsonProcessingException e) {
            throw new RuleExecutionFailedExeption(e.getMessage());
        }

    }

    private void getMoreInfo(List<JsonObject> vulnerabilityInfoList, List<Map<String, Object>> issueDetails) {
        String moreInfo = "";
        for(JsonObject vulnerability  : vulnerabilityInfoList){
            JsonObject pluginDetails = vulnerability.get("plugin").getAsJsonObject();
            JsonArray seeAlsoList = pluginDetails.get("see_also").getAsJsonArray();
            for(JsonElement elem : seeAlsoList){
                moreInfo= moreInfo.concat(elem.getAsString()+" ");
            }
        }
        issueDetails.get(0).put(PacmanRuleConstants.TENABLE_MORE_INFO,moreInfo);
    }

    private List<Map<String, Object>> buildVMIssueDetails(JsonObject elem) {
      List<Map<String,Object>> issues = new ArrayList<>();
      Map<String,Object> issue = new HashMap<>();
      JsonObject pluginDetails = elem.get("plugin").getAsJsonObject();
      JsonObject assetDetails = elem.get("asset").getAsJsonObject();
      issue.putIfAbsent(PacmanRuleConstants.VIOLATION_REASON,formatString(pluginDetails.get("description")));
      issue.putIfAbsent(PacmanRuleConstants.SEVERITY, elem.get(PacmanRuleConstants.SEVERITY).getAsString());
      issue.putIfAbsent(PacmanRuleConstants.TENABLE_SOLUTION, formatString(pluginDetails.get("solution")));
      issue.putIfAbsent(PacmanRuleConstants.HOST_NAME, assetDetails.get("instanceId"));
      issues.add(issue);
    return issues;
  }

  private String formatString(JsonElement element) {
      return  element.isJsonNull() || element.getAsString().isEmpty() ? "Not Provided" : element.getAsString().replaceAll(", ",",");
  }

  @Override
  public String getHelpText() {
    return null;
  }
}

