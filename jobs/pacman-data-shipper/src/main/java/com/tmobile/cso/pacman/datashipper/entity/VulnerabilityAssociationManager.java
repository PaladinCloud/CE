package com.tmobile.cso.pacman.datashipper.entity;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.*;
import com.amazonaws.util.StringUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tmobile.cso.pacman.datashipper.config.CredentialProvider;
import com.tmobile.cso.pacman.datashipper.es.ESManager;
import com.tmobile.cso.pacman.datashipper.util.Constants;
import com.tmobile.pacman.commons.utils.ESUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

public class VulnerabilityAssociationManager {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityAssociationManager.class);

    private static final String S3_ACCOUNT = System.getProperty("base.account");
    private static final String S3_REGION = System.getProperty("base.region");
    private static final String S3_ROLE = System.getProperty("s3.role");
    private static final String BUCKET_NAME = System.getProperty("s3");
    private static final String DATA_PATH = System.getProperty("s3.data");
    private static final String DATE_FORMAT_SEC = "yyyy-MM-dd HH:mm:00Z";
    private static final String VUL_FILE_SUFFIX = "-vulnerabilities.data";
    private static final String DETECTION_FILE_SUFFIX = "-detections.data";
    private static final Map<String, String> sourceFileToIndexMapping = new HashMap<>(2);

    static {
        sourceFileToIndexMapping.put("%s-vulnerabilities", "%s_vulnerability");
        sourceFileToIndexMapping.put("%s-detections", "%s_detection");
    }

    public List<Map<String, String>> uploadVulnerabilityInfo(String dataSource) {
        LOGGER.info("Started Vulnerability collection for - {}", dataSource);
        List<Map<String, String>> errorList = new ArrayList<>();
        AmazonS3 s3Client = AmazonS3ClientBuilder.standard().withCredentials(
                new AWSStaticCredentialsProvider(new CredentialProvider().getCredentials(S3_ACCOUNT, S3_ROLE))).withRegion(S3_REGION).build();
        ObjectMapper objectMapper = new ObjectMapper();

        for (Map.Entry<String, String> entry : sourceFileToIndexMapping.entrySet()) {
            try {
                String indexName = String.format(entry.getValue(), dataSource);
                String filePrefix = String.format(entry.getKey(), dataSource);
                List<Map<String, Object>> entities;
                    ListObjectsV2Request listReq = new ListObjectsV2Request().
                            withBucketName(BUCKET_NAME)
                            .withPrefix(DATA_PATH); // List only files inside this folder
                    ListObjectsV2Result result = s3Client.listObjectsV2(listReq);
                    if(result != null && result.getKeyCount() > 0) {
                        String loadDate = new SimpleDateFormat(DATE_FORMAT_SEC).format(new java.util.Date());
                        for (S3ObjectSummary object : result.getObjectSummaries()) {
                            String fileName = object.getKey();
                            S3Object entitiesData = s3Client.getObject(BUCKET_NAME, fileName);
                            if (fileName.endsWith(VUL_FILE_SUFFIX) && entry.getKey().contains("vulnerabilities") ||
                                    fileName.endsWith(DETECTION_FILE_SUFFIX) && entry.getKey().contains("-detections")) {
                                try (BufferedReader reader = new BufferedReader(new InputStreamReader(entitiesData.getObjectContent()))) {
                                    entities = objectMapper.readValue(reader.lines().collect(Collectors.joining("\n")), new TypeReference<List<Map<String, Object>>>() {
                                    });
                                    if (Objects.isNull(entities)) {
                                        LOGGER.info("{} object is empty for dataSource - {}", filePrefix, dataSource);
                                        continue;
                                    }
                                    uploadEntity(entities, indexName, loadDate);
                                } catch (Exception e) {
                                    LOGGER.info("{} data is empty", filePrefix);
                                }
                            }
                        }

                    }

            } catch (Exception e) {
                LOGGER.error("Error in shipping vulnerability data for dataSource - {}", dataSource);
                Map<String, String> errorMap = new HashMap<>();
                errorMap.put(Constants.ERROR, "Exception in collecting vulnerability data for " + dataSource + " from " + DATA_PATH);
                errorMap.put(Constants.ERROR_TYPE, Constants.WARN);
                errorMap.put(Constants.EXCEPTION, e.getMessage());
                errorList.add(errorMap);
            }
        }
        LOGGER.info("Completed Vulnerability collection for {}", dataSource);
        return errorList;
    }


    public  static void  uploadEntity(List<Map<String, Object>> entities, String indexName, String loadDate) throws Exception{
        String url = ESUtils.getEsUrl();
        if (!ESUtils.isValidIndex(url, indexName)) {
            ESUtils.createIndex(url, indexName);
        }
        entities.parallelStream().filter(obj -> obj.get("closedDate") == null || StringUtils.isNullOrEmpty(obj.get("closedDate").toString()))
                .forEach((obj) -> {
                    obj.remove("closedDate");
                    obj.put("_loaddate", loadDate);
                });
        LOGGER.info("Collected vulnerabilities: {}", entities.size());
        ESManager.uploadVulnerabilityData(indexName, entities);
        ESManager.deleteOldDocuments(indexName, null, "_loaddate.keyword", loadDate);
    }
}
