package com.tmobile.cso.pacman.datashipper.entity;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.GetObjectRequest;
import com.amazonaws.services.s3.model.S3Object;
import com.amazonaws.util.StringUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.tmobile.cso.pacman.datashipper.config.CredentialProvider;
import com.tmobile.cso.pacman.datashipper.es.ESManager;
import com.tmobile.cso.pacman.datashipper.util.Constants;
import com.tmobile.pacman.commons.utils.ESUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

public class VulnerabilityAssociationManager {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityAssociationManager.class);

    private static final String S3_ACCOUNT = System.getProperty("base.account");
    private static final String S3_REGION = System.getProperty("base.region");
    private static final String S3_ROLE = System.getProperty("s3.role");
    private static final String BUCKET_NAME = System.getProperty("s3");
    private static final String DATA_PATH = System.getProperty("s3.data");
    private static final String DATE_FORMAT_SEC = "yyyy-MM-dd HH:mm:00Z";
    private static final String INDEX_SUFFIX = "vulnerability";

    public List<Map<String, String>> uploadVulnerabilityInfo(String dataSource) {
        LOGGER.info("Started Vulnerability collection for - {}", dataSource);
        List<Map<String, String>> errorList = new ArrayList<>();
        AmazonS3 s3Client = AmazonS3ClientBuilder.standard().withCredentials(
                new AWSStaticCredentialsProvider(new CredentialProvider().getCredentials(S3_ACCOUNT, S3_ROLE))).withRegion(S3_REGION).build();
        ObjectMapper objectMapper = new ObjectMapper();

        String indexName;
        try {
            indexName = dataSource + "_" + INDEX_SUFFIX;
            String filePrefix = dataSource + "-vulnerabilities";
            List<Map<String, Object>> entities;
            S3Object entitiesData = s3Client.getObject(new GetObjectRequest(BUCKET_NAME, DATA_PATH + "/" + filePrefix + ".data"));
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(entitiesData.getObjectContent()))) {
                entities = objectMapper.readValue(reader.lines().collect(Collectors.joining("\n")), new TypeReference<List<Map<String, Object>>>() {
                });
            } catch (Exception e) {
                LOGGER.info("vulnerability data is empty");
                return errorList;
            }
            if (Objects.isNull(entities)) {
                LOGGER.info("vulnerability data object is empty for dataSource - {}", dataSource);
                return errorList;
            }
            String url = ESUtils.getEsUrl();
            if (!ESUtils.isValidIndex(url, indexName)) {
                ESUtils.createIndex(url, indexName);
            }
            String loaddate = new SimpleDateFormat(DATE_FORMAT_SEC).format(new java.util.Date());
            entities.parallelStream().filter(obj -> obj.get("closedDate") == null || StringUtils.isNullOrEmpty(obj.get("closedDate").toString()))
                    .forEach((obj) -> {
                        obj.remove("closedDate");
                        obj.put("_loaddate", loaddate);
                    });
            LOGGER.info("Collected vulnerabilities: {}", entities.size());
            ESManager.uploadVulnerabilityData(indexName, entities);
            ESManager.deleteOldDocuments(indexName, null, "_loaddate.keyword", loaddate);
        } catch (Exception e) {
            LOGGER.error("Error in shipping vulnerability data for dataSource - {}", dataSource);
            Map<String, String> errorMap = new HashMap<>();
            errorMap.put(Constants.ERROR, "Exception in collecting vulnerability data for " + dataSource + " from " + DATA_PATH);
            errorMap.put(Constants.ERROR_TYPE, Constants.WARN);
            errorMap.put(Constants.EXCEPTION, e.getMessage());
            errorList.add(errorMap);
        }
        LOGGER.info("Completed Vulnerability collection for {}", dataSource);
        return errorList;
    }
}
