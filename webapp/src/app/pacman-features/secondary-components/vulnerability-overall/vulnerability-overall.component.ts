/*
 *Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); You may not use
 * this file except in compliance with the License. A copy of the License is located at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Component, OnInit, ElementRef, ViewChild, Input, OnDestroy } from '@angular/core';
import { Subscription } from 'rxjs';
import { AssetGroupObservableService } from '../../../core/services/asset-group-observable.service';
import { AutorefreshService } from '../../services/autorefresh.service';
import { environment } from './../../../../environments/environment';
import { ActivatedRoute, Router } from '@angular/router';
import { LoggerService } from '../../../shared/services/logger.service';
import { ErrorHandlingService } from '../../../shared/services/error-handling.service';
import { UtilsService } from '../../../shared/services/utils.service';
import { WorkflowService } from '../../../core/services/workflow.service';
import { CommonResponseService } from '../../../shared/services/common-response.service';

@Component({
  selector: 'app-vulnerability-overall',
  templateUrl: './vulnerability-overall.component.html',
  styleUrls: ['./vulnerability-overall.component.css'],
  providers: [LoggerService, ErrorHandlingService, CommonResponseService, AutorefreshService]
})

export class VulnerabilityOverallComponent implements OnInit, OnDestroy {
  @ViewChild('widget') widgetContainer: ElementRef;

  subscriptionToAssetGroup: Subscription;
  selectedAssetGroup: string;
  public apiData: any;
  public applicationValue: any;
  public errorMessage: any;
  public dataComing = true;
  public showLoader = true;
  public low = false;
  public medium = false;
  public full = false;
  durationParams: any;
  autoRefresh: boolean;
  public graphData: any;
  public widgetWidth: number;
  public widgetHeight: number;
  public colorTransData: any;
  public seekdata = false;
  public graphLegend: any = [];
  public MainTextcolor: any = '';
  public innerRadius = 60;
  public outerRadius = 50;
  public strokeColor = 'transparent';
  public totalGrpahCount = 0;
  routeTo = 'vulnerabilities';
  private urlToRedirect;

  private autorefreshInterval;
  @Input() pageLevel: number;

  constructor(
    private commonResponseService: CommonResponseService,
    private assetGroupObservableService: AssetGroupObservableService,
    private autorefreshService: AutorefreshService,
    private logger: LoggerService, private errorHandling: ErrorHandlingService,
    private router: Router, private activatedRoute: ActivatedRoute,
    private utils: UtilsService,
    private workflowService: WorkflowService
  ) {

    this.subscriptionToAssetGroup = this.assetGroupObservableService.getAssetGroup().subscribe(
      assetGroupName => {
        this.selectedAssetGroup = assetGroupName;
        this.updateComponent();
      });
    this.durationParams = this.autorefreshService.getDuration();
    this.durationParams = parseInt(this.durationParams, 10);
    this.autoRefresh = this.autorefreshService.autoRefresh;
  }

  ngOnInit() {
    this.urlToRedirect = this.router.routerState.snapshot.url;
    this.widgetWidth = parseInt(window.getComputedStyle(this.widgetContainer.nativeElement, null).getPropertyValue('width'), 10);
    this.widgetHeight = parseInt(window.getComputedStyle(this.widgetContainer.nativeElement, null).getPropertyValue('height'), 10);

    const afterLoad = this;
    if (this.autoRefresh !== undefined) {
      if ((this.autoRefresh === true) || (this.autoRefresh.toString() === 'true')) {

        this.autorefreshInterval = setInterval(function () {
          afterLoad.getProgressData();
        }, this.durationParams);
      }
    }
  }

  /* Function to repaint component */
  updateComponent() {

    /* All functions variables which are required to be set for component to be reloaded should go here */
    this.seekdata = false;
    this.dataComing = false;
    this.showLoader = true;
    this.graphData = 0;
    this.getData();
  }

  /* Function to get Data */
  getData() {

    /* All functions to get data should go here */
    this.getProgressData();
  }
  getProgressData() {
    const queryParams = {
      'ag': this.selectedAssetGroup
    };
    const vulnerabilitySummaryUrl = environment.vulnerabilitySummary.url;
    const vulnerabilitySummaryMethod = environment.vulnerabilitySummary.method;

    this.commonResponseService.getData(vulnerabilitySummaryUrl, vulnerabilitySummaryMethod, {}, queryParams).subscribe(
      response => {
        this.apiData = response;
        try {

          if (this.apiData === undefined || this.apiData === '' || this.apiData == null) {
            this.errorMessage = 'noDataAvailable';
            this.getErrorValues();
          } else {
            this.showLoader = false;
            this.seekdata = false;
            this.dataComing = true;
            this.applicationValue = this.apiData.distribution;
            this.processGraphData(this.applicationValue);
            this.getColour(this.applicationValue);
          }
        } catch (error) {
          this.errorMessage = 'noDataAvailable';
          this.getErrorValues();
        }
      },
      error => {
        this.errorMessage = 'apiResponseError';
        this.getErrorValues();
      });

  }

  // assign error values...

  getErrorValues(message?: any): void {
    this.showLoader = false;
    this.dataComing = false;
    this.seekdata = true;
    if (message) {
      this.errorMessage = message;
    }
  }
  /**
   * this function return colour based on value
   */
  getColour(data) {
    if ((data.compliantpercent >= 0) && (data.compliantpercent < 50)) {
      this.low = true;
      this.medium = false;
      this.full = false;
    } else if ((data.compliantpercent >= 50) && (data.compliantpercent < 100)) {
      this.medium = true;
      this.low = false;
      this.full = false;
    } else {
      this.full = true;
      this.low = false;
      this.medium = false;
    }
  }


  /**
   * extract data from response to plot the graph
   */


  processGraphData(data): void {

    /**
     * doughnut chart expects the following inputs
     */


    //  this foreach function checks for total count of graph
    // if totalcount is zero , it doesn't plot the graph


    this.totalGrpahCount = 0;
    data.severityinfo.forEach(element => {
      this.totalGrpahCount = this.totalGrpahCount + element.count;
    });

    if (this.totalGrpahCount < 1) {
      this.graphData = 0;
    } else {
      this.colorTransData = ['#ffb00d', '#f75c03', '#e60127'];
      this.graphLegend = ['S3', 'S4', 'S5'];
      this.MainTextcolor = '#000';
      this.strokeColor = '#EFF3F6';
      this.graphData = data.severityinfo;
      const graphDataArray = [];
      const legendTextcolor = '#555555';
      this.innerRadius = 64;
      this.outerRadius = 50;

      this.graphData.forEach(element => {
        graphDataArray.push(element.count);
      });

      const formattedObject = {
        'color': this.colorTransData,
        'data': graphDataArray,
        'legend': this.graphLegend,
        'totalCount': this.applicationValue.vulnerabilities,
        'legendTextcolor': legendTextcolor,
        'link': true,
        'styling': {
          'cursor': 'pointer'
        }
      };
      this.graphData = formattedObject;
    }

  }

  /**
   * This function navigates the page mentioned in the routeTo variable with a querypareams
   */

  navigatePage(event) {
    try {
      this.workflowService.addRouterSnapshotToLevel(this.router.routerState.snapshot.root);
      const eachParams = {};
      const newParams = this.utils.makeFilterObj(eachParams);
      if (this.routeTo !== undefined) {
        this.router.navigate(['../', this.routeTo], { relativeTo: this.activatedRoute, queryParams: newParams, queryParamsHandling: 'merge' });
      }
    } catch (error) {
      this.errorMessage = this.errorHandling.handleJavascriptError(error);
      this.logger.log('error', error);
    }
  }
  navigateDataTable(event) {
    try {
      this.workflowService.addRouterSnapshotToLevel(this.router.routerState.snapshot.root);
      let queryObj = event;
      queryObj = queryObj.charAt(1);
      const eachParams = { 'severitylevel': queryObj };
      const newParams = this.utils.makeFilterObj(eachParams);

      if ((queryObj !== undefined) && (this.routeTo !== undefined)) {
        this.router.navigate(['../', this.routeTo], { relativeTo: this.activatedRoute, queryParams: newParams, queryParamsHandling: 'merge' });
      }
    } catch (error) {
      this.errorMessage = this.errorHandling.handleJavascriptError(error);
      this.logger.log('error', error);
    }
  }
  /* navigatePage, navigateDataTable function ends here */
  ngOnDestroy() {
    try {
      this.subscriptionToAssetGroup.unsubscribe();
      clearInterval(this.autorefreshInterval);
    } catch (error) {

    }
  }

}
