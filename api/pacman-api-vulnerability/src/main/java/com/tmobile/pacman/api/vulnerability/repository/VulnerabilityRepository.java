/*******************************************************************************
 * Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package com.tmobile.pacman.api.vulnerability.repository;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.PostConstruct;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.entity.ContentType;
import org.apache.http.nio.entity.NStringEntity;
import org.apache.http.util.EntityUtils;
import org.elasticsearch.client.Response;
import org.elasticsearch.client.RestClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.reflect.TypeToken;
import com.tmobile.pacman.api.commons.Constants;
import com.tmobile.pacman.api.commons.exception.DataException;
import com.tmobile.pacman.api.commons.repo.ElasticSearchRepository;
import com.tmobile.pacman.api.commons.repo.PacmanRdsRepository;
import com.tmobile.pacman.api.commons.utils.CommonUtils;
import com.tmobile.pacman.api.commons.utils.PacHttpUtils;
import com.tmobile.pacman.api.vulnerability.domain.TrendNote;

/**
 * This is the Repository layer which makes call to ElasticSearch.
 */
@Repository
public class VulnerabilityRepository implements Constants {

	/** The es host. */
	@Value("${elastic-search.host}")
	private String esHost;

	/** The es port. */
	@Value("${elastic-search.port}")
	private int esPort;

	/** The update ES host. */
	@Value("${elastic-search.update-host}")
	private String updateESHost;

	/** The update ES port. */
	@Value("${elastic-search.update-port}")
	private int updateESPort;

	/** The Constant PROTOCOL. */
	private static final String PROTOCOL = "http";

	/** The es url. */
	private String esUrl;

	/** The elastic search repository. */
	@Autowired
	private ElasticSearchRepository elasticSearchRepository;

	/** The rds repository. */
	@Autowired
	private PacmanRdsRepository rdsRepository;

	/** The Constant LOGGER. */
	private static final Log LOGGER = LogFactory.getLog(VulnerabilityRepository.class);

	/** The rest client. */
	private RestClient restClient;

	/**
	 * Initializes the esUrl.
	 */
	@PostConstruct
	void init() {
		esUrl = PROTOCOL + "://" + esHost + ":" + esPort;
	}

	/**
	 * Gets the all vulnerabilities.
	 *
	 * @param vulnAssetsAffectedQids
	 *            the vuln assets affected qids
	 * @return the all vulnerabilities
	 * @throws DataException
	 *             the DataException
	 */
	public List<Map<String, Object>> getAllVulnerabilities(List<String> vulnAssetsAffectedQids) throws DataException {

		List<Map<String, Object>> results = new ArrayList<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/qualys-kb/kb/_search");
		String responseJson = "";
		try {
			for (int index = 0; index <= (vulnAssetsAffectedQids.size() / THOUSAND_TWENTY_FOUR); index++) {
				int from = index * THOUSAND_TWENTY_FOUR;
				int to = from + THOUSAND_TWENTY_FOUR;
				if (vulnAssetsAffectedQids.size() < to) {
					to = vulnAssetsAffectedQids.size();
				}
				StringBuilder requestBody = new StringBuilder(
						"{\"size\":10000,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"qid.keyword\":");
				requestBody.append(vulnAssetsAffectedQids.subList(from, to));
				requestBody.append("}}");
				requestBody.append("]}}}");
				responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
				elasticSearchRepository.processResponseAndSendTheScrollBack(responseJson, results);
			}
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilityData", e);
			throw new DataException();
		}
		return results;
	}

	public List<Map<String, Object>> getAllVulnerabilitiesByAssetGroup(String assetGroup, String targetType,
			Map<String, Object> mustFilter, List<String> occurrenceFieldList, int from, int size,
			Map<String, Object> mustTermsFilter) throws DataException {
		List<Map<String, Object>> results = new ArrayList<>();
		if (size != 0) {
			try {
				results = elasticSearchRepository.getSortedDataFromESBySize(assetGroup, targetType, mustFilter, null,
						null, occurrenceFieldList, from, size, null, mustTermsFilter, null);
			} catch (Exception e) {
				LOGGER.error("Error in getAllVulnerabilitiesByAssetGroup", e);
				throw new DataException();
			}
		} else {
			try {
				/*
				 * results = vulnerabilityAssetsCount(assetGroup, targetType, mustFilter,
				 * occurrenceFieldList, from, size);
				 */
				results = elasticSearchRepository.getSortedDataFromES(assetGroup, targetType, mustFilter, null, null,
						occurrenceFieldList, mustTermsFilter, null);
			} catch (Exception e) {
				LOGGER.error("Error in getAllVulnerabilitiesByAssetGroup", e);
				throw new DataException();
			}

		}
		for (Map<String, Object> map : results) {
			map.remove("_routing");
			map.remove("_parent");
			map.remove("_id");
		}
		return results;
	}

	public List<Map<String, Object>> getDetailsByResourceId(String assetGroup, Map<String, Object> mustFilter,
			List<String> resourceFieldList, Map<String, Object> mustTermFilter) throws DataException {
		List<Map<String, Object>> results = new ArrayList<>();
		try {

			results = elasticSearchRepository.getSortedDataFromES(assetGroup, null, mustFilter, null, null,
					resourceFieldList, mustTermFilter, null);

		} catch (Exception e) {
			LOGGER.error("Error in getDetailsByResourceId", e);
			throw new DataException();
		}

		return results;
	}

	/**
	 * Gets the assets affected count.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param filter
	 *            the filter
	 * @param parentType
	 *            the parent type
	 * @return the assets affected count
	 */
	public Map<String, Long> getAssetsAffectedCount(String assetGroup, Map<String, String> filter, String parentType) {

		Map<String, Long> assetsAffectedCount = new HashMap<>();
		Map<String, String> filterForQuery = new HashMap<>();
		if (!CollectionUtils.isEmpty(filter)) {
			filterForQuery = new HashMap<>(filter);
		}

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(VULN_INFO);
		urlToQuery.append("/").append(SEARCH);
		String responseJson = "";
		try {
			String severity = SEVERITY_LEVELS;
			if (filterForQuery.containsKey(SEVEITY_LEVEL)) {
				severity = filterForQuery.get(SEVEITY_LEVEL);
				filterForQuery.remove(SEVEITY_LEVEL);
			}

			StringBuilder requestBody = new StringBuilder(
					"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"terms\":{\"severitylevel.keyword\":[");
			requestBody.append(severity + "]}},");
			requestBody.append("{\"has_parent\":{\"parent_type\":\"" + parentType
					+ "\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}");

			if (!filterForQuery.isEmpty()) {
				requestBody.append(",{\"match\":");
				requestBody.append(new GsonBuilder().create().toJson(filterForQuery));
				requestBody.append("}");
			}
			requestBody.append("]}}}}]}},\"aggs\":{\"qid\":{\"terms\":{\"field\":\"qid.keyword\",\"size\":");
			requestBody.append(ES_PAGE_SIZE);
			requestBody.append("}}}}");
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getAssetsAffectedCount from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			JsonArray outerBuckets = aggsJson.getAsJsonObject("qid").getAsJsonArray(BUCKETS);
			if (outerBuckets.size() > 0) {
				for (int i = 0; i < outerBuckets.size(); i++) {
					assetsAffectedCount.put(
							String.valueOf(outerBuckets.get(i).getAsJsonObject().get("key").getAsLong()),
							outerBuckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
				}
			}
		}
		return assetsAffectedCount;
	}

	/**
	 * Gets the vulnerabily across app and env.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param filter
	 *            the filter
	 * @param application
	 *            the application
	 * @param parentType
	 *            the parent type
	 * @param severity
	 *            the severity
	 * @return the vulnerabily across app and env
	 * @throws Exception
	 *             the exception
	 */
	public List<Map<String, Object>> getVulnerabilyAcrossAppAndEnv(String assetGroup, String filter, String application,
			String parentType, String severity) throws Exception {

		List<Map<String, Object>> vulnApplications = new ArrayList<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(parentType);
		urlToQuery.append("/").append(SEARCH);

		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}");
		if (StringUtils.isNotEmpty(application)) {
			requestBody.append(",{\"match\":{\"tags.Application.keyword\":\"");
			requestBody.append(application);
			requestBody.append("\"}}");
		}
		requestBody.append("]}},\"aggs\":{\"apps\":{\"terms\":{\"field\":\"");
		requestBody.append(filter);
		requestBody.append(
				"\",\"size\":10000},\"aggs\":{\"vulns\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"");
		if (StringUtils.isNotEmpty(severity)) {
			requestBody.append("S").append(severity);
			requestBody.append("\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"term\":{\"severitylevel.keyword\":")
					.append(severity).append("}}]}}");
		} else {
			requestBody.append(
					"S3\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel.keyword\":3}},{\"match\":{\"latest\":true}}]}},\"S4\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel.keyword\":4}},{\"match\":{\"latest\":true}}]}},\"S5\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel.keyword\":5}},{\"match\":{\"latest\":true}}]}}");
		}
		requestBody.append("}}}}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilyAcrossAppAndEnv from ES", e);
			throw e;
		}
		JsonParser jsonParser = new JsonParser();
		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
		JsonArray outerBuckets = aggsJson.getAsJsonObject("apps").getAsJsonArray(BUCKETS);
		if (outerBuckets.size() > 0) {
			for (int i = 0; i < outerBuckets.size(); i++) {
				String appName = outerBuckets.get(i).getAsJsonObject().get("key").getAsString();
				List<Map<String, Object>> severityInfo = getSeverityInfo(outerBuckets.get(i).getAsJsonObject()
						.getAsJsonObject(VULN).getAsJsonObject("NAME").getAsJsonObject(BUCKETS), severity);
				Map<String, Object> applicationInfo = new HashMap<>();
				if (filter.equals(TAGS_APPS)) {
					applicationInfo.put(APPS, appName);
				} else {
					applicationInfo.put("environment", appName);
				}
				applicationInfo.put("severityinfo", severityInfo);
				if (StringUtils.isEmpty(severity)) {
					applicationInfo.put(VULNEREBILITIES,
							Integer.valueOf(severityInfo.get(0).get(COUNT).toString())
									+ Integer.valueOf(severityInfo.get(1).get(COUNT).toString())
									+ Integer.valueOf(severityInfo.get(2).get(COUNT).toString()));
				} else {
					applicationInfo.put(VULNEREBILITIES, Integer.valueOf(severityInfo.get(0).get(COUNT).toString()));
				}
				vulnApplications.add(applicationInfo);
			}
		}
		return vulnApplications;
	}

	/**
	 * Gets the vulnerability trend.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param filter
	 *            the filter
	 * @param from
	 *            the from
	 * @param to
	 *            the to
	 * @return the vulnerability trend
	 * @throws Exception
	 *             the exception
	 */
	public List<Map<String, Object>> getVulnerabilityTrend(String assetGroup, Map<String, String> filter, Date from,
			Date to) throws Exception {
		List<Map<String, Object>> vulnTrendList = new ArrayList<>();
		try {

			StringBuilder urlToQuery = new StringBuilder(esUrl).append("/assetgroup_stats/count_vuln/_search");
			StringBuilder request = new StringBuilder(
					"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"ag.keyword\":" + "\"" + assetGroup
							+ "\"}}");

			if (filter != null) {
				Set<String> filterkeys = filter.keySet();
				if (filterkeys.contains(TAGS_APPS)) {
					request.append(
							",{ \"match\": {\"tags.Application.keyword\": " + "\"" + filter.get(TAGS_APPS) + "\"}}");
				}
				if (filterkeys.contains("tags.Environment.keyword")) {
					request.append(",{ \"match\": {\"tags.Environment.keyword\": " + "\""
							+ filter.get("tags.Environment.keyword") + "\"}}");
				}
			}
			String gte = null;
			String lte = null;

			if (from != null) {
				gte = "\"gte\": \"" + new SimpleDateFormat("yyyy-MM-dd").format(from) + "\"";
			}
			if (to != null) {
				lte = "\"lte\": \"" + new SimpleDateFormat("yyyy-MM-dd").format(to) + "\"";
			}

			if (gte != null && lte != null) {
				request.append(",{ \"range\": {\"date\": {" + gte + "," + lte + "}}}");
			} else if (gte != null) {
				request.append(",{ \"range\": {\"date\": {" + gte + "}}}");
			} else {
				request.append(",{ \"range\": {\"date\": {" + lte + "}}}");
			}

			request.append(
					"]}},\"aggs\": {\"date\": {\"date_histogram\": {\"field\": \"date\",\"interval\": \"day\",\"format\": \"yyyy-MM-dd\"},\"aggs\": {\"vulns\": {\"sum\": {\"field\": \"count\"}}}}}}");

			String responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), request.toString());
			JsonParser jsonParser = new JsonParser();
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonArray buckets = resultJson.get(AGGREGATIONS).getAsJsonObject().get("date").getAsJsonObject()
					.get(BUCKETS).getAsJsonArray();
			if (buckets.size() > 0) {
				for (int i = 0; i < buckets.size(); i++) {
					Map<String, Object> trend = new HashMap<>();
					JsonObject bucket = (JsonObject) buckets.get(i);
					String date = bucket.get("key_as_string").getAsString();
					Long count = bucket.get(VULN).getAsJsonObject().get(VALUE).getAsLong();
					trend.put("date", date);
					trend.put(COUNT, count);
					vulnTrendList.add(trend);
				}
			}
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilityTrend from ES", e);
			throw e;
		}

		return vulnTrendList;
	}

	/**
	 * Gets the vulnerabilities distribution.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param parentType
	 *            the parent type
	 * @return the vulnerabilities distribution
	 * @throws Exception
	 *             the exception
	 */
	public List<Map<String, Object>> getVulnerabilitiesDistribution(String assetGroup, String parentType)
			throws Exception {
		List<Map<String, Object>> vulnDistributions = new ArrayList<>();

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(parentType).append("/_search");
		String requestBody = "{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}]}},\"aggs\":{\"apps\":{\"terms\":{\"field\":\"tags.Application.keyword\",\"size\":1000},"
				+ "\"aggs\":{\"envs\":{\"terms\":{\"field\":\"tags.Environment.keyword\",\"size\":1000},\"aggs\":{\"vulns\":{\"children\":{\"type\":\"vulninfo\"},"
				+ "\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"S3\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel.keyword\":3}},{\"match\":{\"latest\":true}}]}},\"S4\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel.keyword\":4}},{\"match\":{\"latest\":true}}]}},\"S5\":{\"bool\":{\"must\":[{\"term\":{\"severitylevel.keyword\":5}},{\"match\":{\"latest\":true}}]}}}}}}}}}}}}}";
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody);
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilitiesDistribution from ES", e);
			throw e;
		}

		JsonParser jsonParser = new JsonParser();
		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
		JsonArray outerBuckets = aggsJson.getAsJsonObject("apps").getAsJsonArray(BUCKETS);
		if (outerBuckets.size() > 0) {
			for (int i = 0; i < outerBuckets.size(); i++) {
				Map<String, Object> applist = new HashMap<>();
				String appName = outerBuckets.get(i).getAsJsonObject().get("key").getAsString();
				JsonArray envs = outerBuckets.get(i).getAsJsonObject().getAsJsonObject("envs").getAsJsonArray(BUCKETS);
				List<Map<String, Object>> envDetails = new ArrayList<>();
				if (envs.size() > 0) {
					for (int j = 0; j < envs.size(); j++) {
						String envName = envs.get(j).getAsJsonObject().get("key").getAsString();
						List<Map<String, Object>> severityInfo = getSeverityInfo(envs.get(j).getAsJsonObject()
								.getAsJsonObject(VULN).getAsJsonObject("NAME").getAsJsonObject(BUCKETS), null);
						Map<String, Object> envSeverity = new HashMap<>();
						envSeverity.put("environment", envName);
						envSeverity.put(SEVERITY_INFO, severityInfo);
						envSeverity.put(VULNEREBILITIES,
								Integer.valueOf(severityInfo.get(0).get(COUNT).toString())
										+ Integer.valueOf(severityInfo.get(ONE).get(COUNT).toString())
										+ Integer.valueOf(severityInfo.get(TWO).get(COUNT).toString()));
						envDetails.add(envSeverity);
					}
				}
				applist.put(APPS, appName);
				applist.put("applicationInfo", envDetails);
				vulnDistributions.add(applist);
			}
		}
		return vulnDistributions;
	}

	/**
	 * Gets the vulnerabilitysummary by resource id.
	 *
	 * @param resourceId
	 *            the resource id
	 * @return the vulnerabilitysummary by resource id
	 */
	public Map<String, Object> getVulnerabilitysummaryByResourceId(String resourceId) {
		
		Map<String, Object> vulnSummary = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl);
		urlToQuery.append("/*");// any index
		urlToQuery.append("/").append(VULN_INFO);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"_resourceid.keyword\":\"");
		requestBody.append(resourceId);
		requestBody.append(
				"\"}},{\"terms\": {\"severitylevel.keyword\": [3,4,5]}}]}},\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"S3\":{\"term\":{\"severitylevel.keyword\":\"3\"}},\"S4\":{\"term\":{\"severitylevel.keyword\":\"4\"}},\"S5\":{\"term\":{\"severitylevel.keyword\":\"5\"}}}}}}}");

		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilitysummaryByResourceId from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get("hits").toString());
			vulnSummary.put(TOTAL, hitsJson.get(TOTAL).getAsLong());
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			try {
				vulnSummary.put(SEVERITY_INFO,
						getSeverityInfo(aggsJson.getAsJsonObject("NAME").getAsJsonObject(BUCKETS), null));
			} catch (Exception e) {
				LOGGER.error("Error in getVulnerabilitysummaryByResourceId ", e);
			}
		}
		return vulnSummary;

	}

	/**
	 * Gets the vulnerability details by resource id.
	 *
	 * @param resourceId
	 *            the resource id
	 * @return the vulnerability details by resource id
	 */
	public List<Map<String, Object>> getVulnerabilityDetailsByResourceId(String resourceId) {

		List<Map<String, Object>> results = new ArrayList<>();
		Long totalDocs = (Long) getVulnerabilitysummaryByResourceId(resourceId).get(TOTAL);
		StringBuilder urlToQueryBuffer = new StringBuilder(esUrl);
		urlToQueryBuffer.append("/*");// any index
		urlToQueryBuffer.append("/").append(VULN_INFO);
		urlToQueryBuffer.append("/").append(SEARCH).append(SCROLL).append(ES_PAGE_SCROLL_TTL);

		String urlToQuery = urlToQueryBuffer.toString();
		String urlToScroll = new StringBuilder(esUrl).append("/").append(SEARCH).append(SLASH_SCROLL).toString();

		StringBuilder requestBody = new StringBuilder(
				"{\"size\":10000,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"terms\":{\"severitylevel.keyword\":[3,4,5]}},{\"match\":{\"_resourceid.keyword\":\"");
		requestBody.append(resourceId);
		requestBody.append("\"}}]}}}");
		String request = requestBody.toString();
		String scrollId = null;
		for (int index = 0; index <= (totalDocs / ES_PAGE_SIZE); index++) {
			try {
				if (!Strings.isNullOrEmpty(scrollId)) {
					request = elasticSearchRepository.buildScrollRequest(scrollId, ES_PAGE_SCROLL_TTL);
					urlToQuery = urlToScroll;
				}
				String responseDetails = PacHttpUtils.doHttpPost(urlToQuery, request);
				scrollId = elasticSearchRepository.processResponseAndSendTheScrollBack(responseDetails, results);
			} catch (Exception e) {
				LOGGER.error("Error in getVulnerabilityDetailsByResourceId", e);
			}
		}
		return results;
	}

	/**
	 * Gets the severity info.
	 *
	 * @param countBucket
	 *            the count bucket
	 * @param severity
	 *            the severity
	 * @return the severity info
	 */
	private List<Map<String, Object>> getSeverityInfo(JsonObject countBucket, String severity) {

		List<Map<String, Object>> severityInfo = new ArrayList<>();
		if (StringUtils.isEmpty(severity)) {
			Map<String, Object> severity3 = new HashMap<>();
			severity3.put(SEVEITY_LEVEL, THREE);
			severity3.put(SEVERITY, "S3");
			severity3.put(COUNT, countBucket.getAsJsonObject("S3").get(DOC_COUNT).getAsLong());
			severity3.put(VULN_COUNT, countBucket.getAsJsonObject("S3").get(DOC_COUNT).getAsLong());
			Map<String, Object> severity4 = new HashMap<>();
			severity4.put(SEVEITY_LEVEL, FOUR);
			severity4.put(SEVERITY, "S4");
			severity4.put(COUNT, countBucket.getAsJsonObject("S4").get(DOC_COUNT).getAsLong());
			severity4.put(VULN_COUNT, countBucket.getAsJsonObject("S4").get(DOC_COUNT).getAsLong());
			Map<String, Object> severity5 = new HashMap<>();
			severity5.put(SEVEITY_LEVEL, FIVE);
			severity5.put(COUNT, countBucket.getAsJsonObject("S5").get(DOC_COUNT).getAsLong());
			severity5.put(SEVERITY, "S5");
			severity5.put(VULN_COUNT, countBucket.getAsJsonObject("S5").get(DOC_COUNT).getAsLong());
			severityInfo.add(severity3);
			severityInfo.add(severity4);
			severityInfo.add(severity5);
		} else {
			Map<String, Object> severityMap = new HashMap<>();
			severityMap.put(SEVEITY_LEVEL, Integer.valueOf(severity));
			severityMap.put(COUNT, countBucket.getAsJsonObject("S" + severity).get(DOC_COUNT).getAsLong());
			severityMap.put(SEVERITY, "S" + severity);
			severityMap.put(VULN_COUNT, countBucket.getAsJsonObject("S" + severity).get(DOC_COUNT).getAsLong());
			severityInfo.add(severityMap);
		}

		return severityInfo;
	}

	/**
	 * Fetch exec director apps.
	 *
	 * @return the list
	 * @throws Exception
	 *             the exception
	 */
	@SuppressWarnings("deprecation")
	public List<Map<String, Object>> fetchExecDirectorApps() throws Exception {
		Map<String, Object> mustFilter = new HashMap<>();
		mustFilter.put(Constants.LATEST, Constants.TRUE);
		return elasticSearchRepository.getDataFromES("aws_apps", "apps", mustFilter, null, null,
				Arrays.asList("appTag", "director", "executiveSponsor"), null);

	}

	/**
	 * Gets the unique host.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @return the unique host
	 */
	public Map<String, Object> getUniqueHost(String assetGroup, String severity) {

		Map<String, Object> uniqueHost = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":["
						+ severity + "]}}]}}}}]}},\"aggs\":{\"vulninfo\":{\"children\":{\"type\":\"vulninfo\"},"
						+ "\"aggs\":{\"sev-filter\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":["
						+ severity + "]}}]}},"
						+ "\"aggs\":{\"severity\":{\"terms\":{\"field\":\"severitylevel.keyword\",\"size\":5},"
						+ "\"aggs\":{\"unique-host\":{\"cardinality\":{\"field\":\"_resourceid.keyword\",\"precision_threshold\":40000}}}}}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error(Constants.ERROR_UNIQUEHOST, e);
		}

		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);

			JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(HITS).toString());
			long total = hitsJson.get(TOTAL).getAsLong();
			uniqueHost.put(TOTAL, total);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			JsonArray buckets = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter")
					.getAsJsonObject(SEVERITY).getAsJsonArray(BUCKETS);
			if (buckets.size() > 0) {
				for (int i = 0; i < buckets.size(); i++) {
					uniqueHost.put(buckets.get(i).getAsJsonObject().get("key").getAsString(), buckets.get(i)
							.getAsJsonObject().get("unique-host").getAsJsonObject().get(VALUE).getAsLong());
				}
			}
		}
		return uniqueHost;
	}

	/**
	 * Gets the unique vuln.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @return the unique vuln
	 */
	public Map<String, Object> getVulnInfo(String assetGroup, String severity) {

		Map<String, Object> vulnInfo = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":["
						+ severity + "]}}]}}}}]}},\"aggs\":{\"vulninfo\":{\"children\":{\"type\":\"vulninfo\"},"
						+ "\"aggs\":{\"sev-filter\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":["
						+ severity + "]}}]}},"
						+ "\"aggs\":{\"severity\":{\"terms\":{\"field\":\"severitylevel.keyword\",\"size\":5},"
						+ "\"aggs\":{\"unique-qid\":{\"cardinality\":{\"script\":\"doc['qid.keyword'].toString().replace('.0','')\",\"precision_threshold\": 40000}}}}}}}}}}");

		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error(Constants.ERROR_UNIQUEHOST, e);
		}

		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			long total = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter").get(DOC_COUNT).getAsLong();
			vulnInfo.put(TOTAL, total);
			JsonArray buckets = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter")
					.getAsJsonObject(SEVERITY).getAsJsonArray(BUCKETS);

			Map<String, Object> sevInfo;
			if (buckets.size() > 0) {
				for (int i = 0; i < buckets.size(); i++) {
					String sevKey = buckets.get(i).getAsJsonObject().get("key").getAsString();
					sevInfo = new HashMap<>();
					sevInfo.put(SEVERITY, sevKey);
					sevInfo.put(UNIQUE_VULN_COUNT,
							buckets.get(i).getAsJsonObject().get(UNIQUE_QID).getAsJsonObject().get(VALUE).getAsLong());
					sevInfo.put(VULN_COUNT, buckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
					vulnInfo.put(sevKey, sevInfo);
				}
			}
		}
		return vulnInfo;
	}

	/**
	 * Gets the unique app.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @return the unique app
	 */
	public Map<String, Object> getUniqueApp(String assetGroup) {

		Map<String, Object> uniqueApp = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append("_search?filter_path=aggregations");
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"_entity\":true}}]}},"
						+ "\"aggs\":{\"severity\":{\"filters\":{\"filters\":{"
						+ "\"S3\":{\"has_child\":{\"type\":\"vulninfo\",\"query\":{ \"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"severitylevel.keyword\":3}}]}}}},"
						+ "\"S4\":{\"has_child\":{\"type\":\"vulninfo\",\"query\":{ \"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"severitylevel.keyword\":4}}]}}}},"
						+ "\"S5\":{\"has_child\":{\"type\":\"vulninfo\",\"query\":{ \"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"match\":{\"severitylevel.keyword\":5}}]}}}}}},"
						+ "\"aggs\":{\"NAME\":{\"cardinality\":{\"field\":\"tags.Application.keyword\",\"precision_threshold\": 40000}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error(Constants.ERROR_UNIQUEHOST, e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			JsonObject buckets = aggsJson.getAsJsonObject(SEVERITY).getAsJsonObject(BUCKETS);
			for (int i = 3; i <= 5; i++) {
				uniqueApp.put(String.valueOf(i),
						buckets.get("S" + i).getAsJsonObject().get("NAME").getAsJsonObject().get(VALUE).getAsLong());
			}
		}
		return uniqueApp;
	}

	/**
	 * Gets the aging summary.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @return the aging summary
	 */
	public List<Map<String, Object>> getAgingSummary(String assetGroup) {

		List<Map<String, Object>> agingSummary = new ArrayList<>();
		Map<String, Double> avgAgingMap = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(VULN_INFO);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"terms\":{\"severitylevel.keyword\":[3,4,5]}}]}},"
						+ "\"aggs\":{\"severity\":{\"terms\":{\"field\":\"severitylevel.keyword\",\"size\":10},\"aggs\":{\"aging\":{\"avg\":{\"field\":\"_vulnage\"}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getAgingSummary from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			JsonArray buckets = aggsJson.getAsJsonObject(SEVERITY).getAsJsonArray(BUCKETS);
			if (buckets.size() > 0) {
				for (int i = 0; i < buckets.size(); i++) {
					avgAgingMap.put(buckets.get(i).getAsJsonObject().get("key").toString(), Math.floor(
							buckets.get(i).getAsJsonObject().get(AGING).getAsJsonObject().get(VALUE).getAsDouble()));
				}
			}

			avgAgingMap.forEach((severity, avg) -> {
				Map<String, Object> sevInfo = new HashMap<>();
				sevInfo.put(SEVERITY, "S" + severity);
				sevInfo.put("days", avg);
				agingSummary.add(sevInfo);
			});
		}
		return agingSummary;
	}

	/**
	 * Gets the total qualys host count.
	 *
	 * @param index
	 *            the index
	 * @param vulnType
	 *            the vuln type
	 * @return the total qualys host count
	 * @throws DataException
	 *             the data exception
	 */
	public long getTotalQualysHostCount(String index, String vulnType) throws DataException {
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(index).append("/").append(vulnType)
				.append("/").append(UNDERSCORE_COUNT);
		StringBuilder requestBody = new StringBuilder(
				"{\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"has_child\":{\"type\":\"qualysinfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}}]}}}}]}}}");
		try {
			String responseDetails = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
			JsonObject responseObj = (JsonObject) new JsonParser().parse(responseDetails);
			return (long) responseObj.get("count").getAsLong();
		} catch (Exception e) {
			LOGGER.error("Error in getTotalQualysAssetCount", e);
			throw new DataException(e);
		}
	}

	/**
	 * Gets the vulnerability by qid.
	 *
	 * @param qid
	 *            the qid
	 * @return the vulnerability by qid
	 */
	public Map<String, Object> getVulnerabilityByQid(String qid) {

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append("qualys-kb/kb/_search");
		StringBuilder requestBody = new StringBuilder(
				"{\"query\":{\"bool\":{\"must\":[{\"term\":{\"latest\":\"true\"}},{\"term\":{\"qid.keyword\":\"");
		requestBody.append(qid);
		requestBody.append("\"}}]}}}");

		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilityByQid from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		Map<String, Object> vuln = new HashMap<>();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonArray hits = resultJson.get("hits").getAsJsonObject().get("hits").getAsJsonArray();
			if (hits.size() > 0) {
				for (int i = 0; i < hits.size(); i++) {
					JsonObject obj = (JsonObject) hits.get(i);
					JsonObject sourceJson = (JsonObject) obj.get("_source");
					if (sourceJson != null) {
						vuln = new Gson().fromJson(sourceJson, new TypeToken<Map<String, Object>>() {
						}.getType());
						vuln.remove("latest");
						vuln.remove("_loadDate");
					}
				}
			}
		}
		return vuln;
	}

	/**
	 * Gets the unique vuln with parent.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severitylevel
	 *            the severitylevel
	 * @param parentType
	 *            the parent type
	 * @return the vulnerability by qid
	 * @throws DataException
	 *             the data exception
	 */
	public Map<String, Object> getDistributionSummaryByInfraType(String assetGroup, String severitylevel,
			String parentType) throws DataException {

		Map<String, Object> infraInfo = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(parentType);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},"
						+ "{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},"
						+ "{\"terms\":{\"severitylevel.keyword\":[%s]}}]}}}}]}},\"aggs\":{\"NAME\":{\"children\":{\"type\":\"vulninfo\"},"
						+ "\"aggs\":{\"NAME\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[%s]}}]}},"
						+ "\"aggs\":{\"NAME\":{\"cardinality\":{\"script\":\"doc['qid.keyword'].toString().replace('.0','')\",\"precision_threshold\":40000}}}}}}}}");
		String requestJson = String.format(requestBody.toString(), severitylevel, severitylevel);
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestJson);
		} catch (Exception e) {
			LOGGER.error("Error in getDistributionSummaryByInfraType", e);
			throw new DataException(e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(HITS).toString());
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			long totalVulnerableAssets = hitsJson.get(TOTAL).getAsLong();
			long vulnerabilities = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase())
					.get(DOC_COUNT).getAsLong();
			long uniqueVulnCount = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase())
					.getAsJsonObject(NAME.toUpperCase()).get(VALUE).getAsLong();

			infraInfo.put(TOTAL_VULN_ASSETS, totalVulnerableAssets);
			infraInfo.put(VULNEREBILITIES, vulnerabilities);
			infraInfo.put(UNIQUE_VULN_COUNT, uniqueVulnCount);
		}
		return infraInfo;
	}

	/**
	 * Gets the prod info by env.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severitylevel
	 *            the severitylevel
	 * @return the prod info by env
	 */
	public Map<String, Long> getProdInfoByEnv(String assetGroup, String severitylevel) {

		Map<String, Long> prodInfo = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(SEARCH);

		StringBuilder requestbody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},");
		requestbody.append("{\"terms\":{\"severitylevel.keyword\":[%s]}}]}}}}],")
				.append("\"should\":[{\"prefix\":{\"tags.Environment.keyword\":\"Production\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"production\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"Prd\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"prd\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"PRD\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"Prod\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"PROD\"}}],")
				.append("\"minimum_should_match\":1}},")
				.append("\"aggs\":{\"NAME\":{\"children\":{\"type\":\"vulninfo\"},")
				.append("\"aggs\":{\"NAME\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[%s]}}]}},")
				.append("\"aggs\":{\"NAME\":{\"cardinality\":{\"script\":\"doc['qid.keyword'].toString().replace('.0','')\",\"precision_threshold\": 40000}}}}}}}}");
		String requestJson = String.format(requestbody.toString(), severitylevel, severitylevel);
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestJson);
		} catch (Exception e) {
			LOGGER.error("Error in getProdInfoByEnv", e);
		}

		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(HITS).toString());
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			long totalVulnerableAssets = hitsJson.get(TOTAL).getAsLong();
			long vulnerabilities = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase())
					.get(DOC_COUNT).getAsLong();
			long uniqueVulnCount = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase())
					.getAsJsonObject(NAME.toUpperCase()).get(VALUE).getAsLong();

			prodInfo.put(TOTAL_VULN_ASSETS, totalVulnerableAssets);
			prodInfo.put(VULNEREBILITIES, vulnerabilities);
			prodInfo.put(UNIQUE_VULN_COUNT, uniqueVulnCount);
		}

		return prodInfo;

	}

	/**
	 * Gets the non prod info by env.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severitylevel
	 *            the severitylevel
	 * @return the non prod info by env
	 */
	public Map<String, Long> getNonProdInfoByEnv(String assetGroup, String severitylevel) {

		Map<String, Long> nonProdInfo = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(SEARCH);

		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},");
		requestBody.append(
				"{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[%s]}}]}}}}],")
				.append("\"must_not\":[").append("{\"prefix\":{\"tags.Environment.keyword\":\"Production\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"production\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"Prd\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"prd\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"PRD\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"Prod\"}},")
				.append("{\"prefix\":{\"tags.Environment.keyword\":\"PROD\"}}]}},")
				.append("\"aggs\":{\"NAME\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"NAME\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[%s]}}]}},")
				.append("\"aggs\":{\"NAME\":{\"cardinality\":{\"script\":\"doc['qid.keyword'].toString().replace('.0','')\",\"precision_threshold\": 40000}}}}}}}}");
		String requestJson = String.format(requestBody.toString(), severitylevel, severitylevel);
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestJson);
		} catch (Exception e) {
			LOGGER.error("Error in getNonProdInfoByEnv", e);
		}

		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonObject hitsJson = (JsonObject) jsonParser.parse(resultJson.get(HITS).toString());
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			long totalVulnerableAssets = hitsJson.get(TOTAL).getAsLong();
			long vulnerabilities = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase())
					.get(DOC_COUNT).getAsLong();
			long uniqueVulnCount = aggsJson.getAsJsonObject(NAME.toUpperCase()).getAsJsonObject(NAME.toUpperCase())
					.getAsJsonObject(NAME.toUpperCase()).get(VALUE).getAsLong();

			nonProdInfo.put(TOTAL_VULN_ASSETS, totalVulnerableAssets);
			nonProdInfo.put(VULNEREBILITIES, vulnerabilities);
			nonProdInfo.put(UNIQUE_VULN_COUNT, uniqueVulnCount);
		}
		return nonProdInfo;

	}

	/**
	 * Gets the distribution summary by vuln type.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @return the distribution summary by vuln type
	 * @throws DataException
	 *             the data exception
	 */
	public List<Map<String, Object>> getDistributionSummaryByVulnType(String assetGroup, String severity)
			throws DataException {

		List<Map<String, Object>> distributionList = new ArrayList<>();
		long totalVulnCount = 0;
		Map<String, Object> infoOS = new HashMap<>();
		infoOS.put("category", "OS");
		infoOS.put(TOTAL_VULN_ASSETS, 0);
		infoOS.put(VULNEREBILITIES, 0);
		infoOS.put(UNIQUE_VULN_COUNT, 0);

		Map<String, Object> infoApp = new HashMap<>();
		infoApp.put("category", "Application");
		infoApp.put(TOTAL_VULN_ASSETS, 0);
		infoApp.put(VULNEREBILITIES, 0);
		infoApp.put(UNIQUE_VULN_COUNT, 0);

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},").append(
						"{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[%s]}}]}}}}]}},")
						.append("\"aggs\":{\"vulninfo\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"sev-filter\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[%s]}}]}},")
						.append("\"aggs\":{\"classification\":{\"terms\":{\"field\":\"classification.keyword\",\"size\":10},\"aggs\":{\"resources\":{\"cardinality\":{\"field\":\"_resourceid.keyword\",\"precision_threshold\":40000}}}}}}}}}}");

		String requestJson = String.format(requestBody.toString(), severity, severity);
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestJson);
		} catch (Exception e) {
			LOGGER.error("Error in getVulnerabilitySummaryByClassification from ES", e);
			throw new DataException(e);
		}

		JsonParser jsonParser = new JsonParser();
		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
		JsonArray buckets = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter")
				.getAsJsonObject("classification").getAsJsonArray(BUCKETS);
		if (buckets.size() > 0) {
			for (int i = 0; i < buckets.size(); i++) {
				totalVulnCount += buckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong();
				if (buckets.get(i).getAsJsonObject().get("key").toString().replace("\"", "").equals("OS")) {
					infoOS.put(TOTAL_VULN_ASSETS,
							buckets.get(i).getAsJsonObject().get("resources").getAsJsonObject().get(VALUE).getAsLong());
					infoOS.put(VULNEREBILITIES, buckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
				} else {
					infoApp.put(TOTAL_VULN_ASSETS,
							buckets.get(i).getAsJsonObject().get("resources").getAsJsonObject().get(VALUE).getAsLong());
					infoApp.put(VULNEREBILITIES, buckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
				}
			}
		}

		requestBody = new StringBuilder("{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},")
				.append("{\"has_child\":{\"type\":\"vulninfo\",\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[%s]}}]}}}}]}},")
				.append("\"aggs\":{\"vulninfo\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"sev-filter\":{\"filter\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[%s]}}]}},")
				.append("\"aggs\":{\"classification\":{\"terms\":{\"field\":\"classification.keyword\",\"size\":10},\"aggs\":{\"unique-qid\":{\"cardinality\":{\"script\":\"doc['qid.keyword'].toString().replace('.0','')\",\"precision_threshold\":40000}}}}}}}}}}");

		requestJson = String.format(requestBody.toString(), severity, severity);
		responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestJson);
		} catch (Exception e) {
			LOGGER.error(Constants.ERROR_UNIQUEHOST, e);
			throw new DataException(e);
		}

		resultJson = (JsonObject) jsonParser.parse(responseJson);
		aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
		buckets = aggsJson.getAsJsonObject(VULN_INFO).getAsJsonObject("sev-filter").getAsJsonObject("classification")
				.getAsJsonArray(BUCKETS);
		if (buckets.size() > 0) {
			for (int i = 0; i < buckets.size(); i++) {
				if (buckets.get(i).getAsJsonObject().get("key").toString().replace("\"", "").equals("OS")) {
					infoOS.put(UNIQUE_VULN_COUNT,
							buckets.get(i).getAsJsonObject().get(UNIQUE_QID).getAsJsonObject().get(VALUE).getAsLong());
				} else {
					infoApp.put(UNIQUE_VULN_COUNT,
							buckets.get(i).getAsJsonObject().get(UNIQUE_QID).getAsJsonObject().get(VALUE).getAsLong());
				}
			}
		}

		if (totalVulnCount > 0) {
			distributionList.add(infoOS);
			distributionList.add(infoApp);
		}
		double contribution = HUNDRED;
		for (int i = 0; i < distributionList.size(); i++) {
			Map<String, Object> info = distributionList.get(i);
			if (totalVulnCount > 0) {
				double contributionPercent = Math
						.floor((Double.valueOf(info.get(VULNEREBILITIES).toString()) / totalVulnCount) * HUNDRED);
				if (i == distributionList.size() - 1) {
					info.put("contribution", contribution);
				} else {
					info.put("contribution", contributionPercent);
					contribution = contribution - contributionPercent;
				}
			}
		}
		return distributionList;
	}

	/**
	 * Gets the all qid by AG.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @return the all qid by AG
	 * @throws DataException
	 *             the data exception
	 */
	public Map<String, Object> getAllQidByAG(String assetGroup, String severity) throws DataException {

		Map<String, Object> qids = new HashMap<>();

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(VULN_INFO);
		urlToQuery.append("/").append(SEARCH);
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[");
		requestBody.append(severity);
		requestBody.append(
				"]}}]}},\"aggs\":{\"qid\":{\"terms\":{\"script\":\"(doc['qid.keyword'].value+'~').replace('.0','')+doc['title.keyword'].value.toLowerCase()+'~'+doc['classification.keyword'].value\",\"size\":100000}}}}");

		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getAllQidByAG from ES", e);
			throw new DataException(e);
		}
		JsonParser jsonParser = new JsonParser();
		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
		JsonArray buckets = aggsJson.getAsJsonObject("qid").getAsJsonArray(BUCKETS);
		if (buckets.size() > 0) {
			for (int i = 0; i < buckets.size(); i++) {
				qids.put(buckets.get(i).getAsJsonObject().get("key").toString().replace("\"", ""),
						buckets.get(i).getAsJsonObject().get(DOC_COUNT));
			}
		}
		return qids;
	}

	/**
	 * Gets the apps by severity.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param parentType
	 *            the parent type
	 * @param severity
	 *            the severity
	 * @return the apps by severity
	 * @throws Exception
	 *             the exception
	 */
	public Map<String, Long> getAppsBySeverity(String assetGroup, String parentType, String severity) throws Exception {

		Map<String, Long> appDetails = new HashMap<>();
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup);
		urlToQuery.append("/").append(parentType);
		urlToQuery.append("/").append(SEARCH);

		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}}]}},"
						+ "\"aggs\":{\"apps\":{\"terms\":{\"field\":\"tags.Application.keyword\",\"size\":10000},"
						+ "\"aggs\":{\"vulns\":{\"children\":{\"type\":\"vulninfo\"},\"aggs\":{\"NAME\":{\"filters\":{\"filters\":{\"severity\":{\"terms\":{\"severitylevel.keyword\":[");
		requestBody.append(severity);
		requestBody.append("]}}}}}}}}}}}");
		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getAppsBySeverity from ES", e);
			throw e;
		}
		JsonParser jsonParser = new JsonParser();
		JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
		JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
		JsonArray buckets = aggsJson.getAsJsonObject("apps").getAsJsonArray(BUCKETS);
		if (buckets.size() > 0) {
			for (int i = 0; i < buckets.size(); i++) {
				appDetails.put(buckets.get(i).getAsJsonObject().get("key").getAsString(),
						buckets.get(i).getAsJsonObject().getAsJsonObject("vulns").getAsJsonObject("NAME")
								.getAsJsonObject("buckets").getAsJsonObject("severity").get(DOC_COUNT).getAsLong());
			}
		}
		return appDetails;
	}

	/**
	 * Creates the trend annotation.
	 *
	 * @param request
	 *            the request
	 * @return true, if successful
	 * @throws JsonProcessingException
	 *             the json processing exception
	 */
	public boolean createTrendAnnotation(TrendNote request) throws JsonProcessingException {

		SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd");
		SimpleDateFormat dateformatId = new SimpleDateFormat("yyyyMMdd");
		String assetGroup;
		if (StringUtils.isBlank(request.getAg())) {
			assetGroup = "";
		} else {
			assetGroup = request.getAg();
		}
		Date date = request.getDate();
		Map<String, Object> payLoad = new HashMap<>();
		payLoad.put("ag", assetGroup);
		payLoad.put("note", request.getNote());
		payLoad.put("date", dateformat.format(date));
		if (StringUtils.isEmpty(assetGroup)) {
			payLoad.put(NOTE_ID, dateformatId.format(date));
		} else {
			payLoad.put(NOTE_ID, assetGroup + "_" + dateformatId.format(date));
		}

		List<Map<String, Object>> docs = new ArrayList<>();
		docs.add(payLoad);
		createIndex("assetgroup_annotations");
		return uploadData("assetgroup_annotations", "annotations", docs, NOTE_ID);
	}

	/**
	 * Creates the index.
	 *
	 * @param indexName
	 *            the index name
	 */
	public void createIndex(String indexName) {
		if (!indexExists(indexName)) {
			String payLoad = "{\"settings\": {  \"number_of_shards\" : 1,\"number_of_replicas\" : 1,\"index.mapping.ignore_malformed\": true }}";
			invokeAPI("PUT", indexName, payLoad);
		}
	}

	/**
	 * Index exists.
	 *
	 * @param indexName
	 *            the index name
	 * @return true, if successful
	 */
	private boolean indexExists(String indexName) {
		Response response = invokeAPI("HEAD", indexName, null);
		if (response != null) {
			return response.getStatusLine().getStatusCode() == 200 ? true : false;
		}
		return false;
	}

	/**
	 * Upload data.
	 *
	 * @param index
	 *            the index
	 * @param type
	 *            the type
	 * @param docs
	 *            the docs
	 * @param idKey
	 *            the id key
	 * @return true, if successful
	 */
	private boolean uploadData(String index, String type, List<Map<String, Object>> docs, String idKey) {
		String actionTemplate = "{ \"index\" : { \"_index\" : \"%s\", \"_type\" : \"%s\", \"_id\" : \"%s\"} }%n";

		LOGGER.info("*********UPLOADING*** " + type);
		if (null != docs && !docs.isEmpty()) {
			StringBuilder bulkRequest = new StringBuilder();
			int i = 0;
			for (Map<String, Object> doc : docs) {
				if (doc != null) {
					String id = doc.get(idKey).toString();
					StringBuilder docStrBuilder = new StringBuilder(createESDoc(doc));

					if (docStrBuilder != null) {
						bulkRequest.append(String.format(actionTemplate, index, type, id));
						bulkRequest.append(docStrBuilder + "\n");
					}
					i++;
					if (i % Constants.THOUSAND == 0 || bulkRequest.toString().getBytes().length
							/ (Constants.THOUSAND_TWENTY_FOUR * Constants.THOUSAND_TWENTY_FOUR) > Constants.FIVE) {
						LOGGER.info("Uploaded" + i);
						Response resp = invokeAPI("POST", "/_bulk?refresh=true", bulkRequest.toString());
						try {
							String responseStr = "";
							if (null != resp) {
								responseStr = EntityUtils.toString(resp.getEntity());
							}
							if (responseStr.contains("\"errors\":true")) {
								Response retryResp = invokeAPI("POST", "/_bulk?refresh=true", bulkRequest.toString());
								String retryResponse = "";
								if (null != retryResp) {
									retryResponse = EntityUtils.toString(retryResp.getEntity());
								}
								if (retryResponse.contains("\"errors\":true")) {
									LOGGER.error(retryResponse);
								}
							}
						} catch (Exception e) {
							LOGGER.error("Bulk upload failed", e);
							return false;
						}
						bulkRequest = new StringBuilder();
					}
				}
			}
			if (bulkRequest.length() > 0) {
				LOGGER.info("Uploaded" + i);
				Response resp = invokeAPI("POST", "/_bulk?refresh=true", bulkRequest.toString());
				try {
					String responseStr = "";
					if (null != resp) {
						responseStr = EntityUtils.toString(resp.getEntity());
					}
					if (responseStr.contains("\"errors\":true")) {
						Response retryResp = invokeAPI("POST", "/_bulk?refresh=true", bulkRequest.toString());
						String retryResponse = "";
						if (null != retryResp) {
							retryResponse = EntityUtils.toString(retryResp.getEntity());
						}

						if (retryResponse.contains("\"errors\":true")) {
							LOGGER.error(retryResponse);
						}
					}
					if (null != resp) {
						return resp.getStatusLine().getStatusCode() == 200 ? true : false;
					} else {
						return false;
					}
				} catch (Exception e) {
					LOGGER.error("Bulk upload failed", e);
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * Creates the ES doc.
	 *
	 * @param doc
	 *            the doc
	 * @return the string
	 */
	private String createESDoc(Map<String, ?> doc) {
		ObjectMapper objMapper = new ObjectMapper();
		String docJson = "{}";
		try {
			docJson = objMapper.writeValueAsString(doc);
		} catch (JsonProcessingException e) {
			LOGGER.error("Error in createESDoc", e);
		}
		return docJson;
	}

	/**
	 * Invoke API.
	 *
	 * @param method
	 *            the method
	 * @param endpoint
	 *            the endpoint
	 * @param payLoad
	 *            the pay load
	 * @return the response
	 */
	private Response invokeAPI(String method, String endpoint, String payLoad) {
		HttpEntity entity = null;
		try {
			if (payLoad != null) {
				entity = new NStringEntity(payLoad, ContentType.APPLICATION_JSON);
			}
			return getRestClient().performRequest(method, endpoint, Collections.<String, String>emptyMap(), entity);
		} catch (IOException e) {
			LOGGER.error("Error in invokeAPI", e);
		}
		return null;
	}

	/**
	 * Gets the rest client.
	 *
	 * @return the rest client
	 */
	private RestClient getRestClient() {
		if (restClient == null) {
			restClient = RestClient.builder(new HttpHost(updateESHost, updateESPort)).build();
		}
		return restClient;
	}

	/**
	 * Gets the trend annotations.
	 *
	 * @param ag
	 *            the ag
	 * @param from
	 *            the from
	 * @return the trend annotations
	 */
	public List<Map<String, Object>> getTrendAnnotations(String ag, Date from) {

		List<Map<String, Object>> notes = new ArrayList<>();
		SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd");

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/")
				.append("assetgroup_annotations/annotations/_search");
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":10000,\"query\":{\"bool\":{\"must\":[{\"range\":{\"date\":{\"gte\":\"");
		requestBody.append(dateformat.format(from));
		requestBody.append("\",\"lte\":\"");
		requestBody.append(dateformat.format(new Date()));
		requestBody.append("\",\"format\":\"yyyy-MM-dd\"}}}");
		requestBody.append(",{\"terms\":{\"ag.keyword\":[\"\",\"");
		requestBody.append(ag).append("\"]}}]}}}");

		String responseJson = "";
		try {
			responseJson = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getTrendAnnotations from ES", e);
		}
		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseJson)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseJson);
			JsonArray hits = resultJson.get("hits").getAsJsonObject().get("hits").getAsJsonArray();
			Map<String, Object> note;
			if (hits.size() > 0) {
				for (int i = 0; i < hits.size(); i++) {
					JsonObject obj = (JsonObject) hits.get(i);
					JsonObject sourceJson = (JsonObject) obj.get("_source");
					if (sourceJson != null) {
						note = new Gson().fromJson(sourceJson, new TypeToken<Map<String, Object>>() {
						}.getType());
						notes.add(note);
					}
				}
			}
		}
		return notes;
	}

	/**
	 * Delete trend annotation.
	 *
	 * @param noteId
	 *            the note id
	 * @return true, if successful
	 */
	public boolean deleteTrendAnnotation(String noteId) {
		boolean result = false;
		try {
			result = invokeAPI("POST", "assetgroup_annotations/annotations/_delete_by_query?refresh&q=_id:" + noteId,
					null).getStatusLine().getStatusCode() == 200;
		} catch (Exception e) {
			LOGGER.error("Error in deleteTrendAnnotation ", e);
		}
		return result;
	}

	/**
	 * Gets the data from pacman RDS.
	 *
	 * @param query
	 *            the query
	 * @return the data from pacman RDS
	 */
	public List<Map<String, Object>> getDataFromPacmanRDS(String query) {
		return rdsRepository.getDataFromPacman(query);
	}

	/**
	 * Gets the running instances count.
	 *
	 * @param index
	 *            the index
	 * @param vulnType
	 *            the vuln type
	 * @return the running instances count
	 * @throws DataException
	 *             the data exception
	 */
	public long getRunningInstancesCount(String index, String vulnType) throws DataException {
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(index).append("/").append(vulnType)
				.append("/").append(UNDERSCORE_COUNT);
		StringBuilder requestBody = new StringBuilder(
				"{\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}}");
		if (vulnType.equals(EC2)) {
			requestBody.append(",{\"match\":{\"statename\":\"running\"}}");
		}
		requestBody.append("]}}}");

		try {
			String responseDetails = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
			JsonObject responseObj = (JsonObject) new JsonParser().parse(responseDetails);
			return responseObj.get("count").getAsLong();
		} catch (Exception e) {
			LOGGER.error("Error in getRunningInstancesCount", e);
			throw new DataException(e);
		}
	}

	/**
	 * Gets the exempted by rule count.
	 *
	 * @param index
	 *            the index
	 * @param vulnType
	 *            the vuln type
	 * @return the exempted by rule count
	 * @throws DataException
	 *             the data exception
	 */
	public long getExemptedByRuleCount(String index, String vulnType) throws DataException {
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(index).append("/")
				.append(UNDERSCORE_COUNT);
		StringBuilder requestBody = new StringBuilder(
				"{\"query\":{\"bool\":{\"must\":[{\"match\":{\"issueStatus.keyword\":\"exempted\"}},{\"match\":{\"ruleId.keyword\":\"");
		if (vulnType.equals(EC2)) {
			requestBody.append(EC2_QUALYS_RULEID);
		}else if(vulnType.equals(VIRTUALMACHINE)) {
			requestBody.append(VIRTUALMACHINE_QUALYS_RULEID);
		}else {
			requestBody.append(
					"Onprem-asset-scanned-by-qualys-API_version-1_OnpremassetscannedbyqualysAPI_onpremserver");
		}
		requestBody.append("\"}}]}}}");

		try {
			String responseDetails = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
			JsonObject responseObj = (JsonObject) new JsonParser().parse(responseDetails);
			return responseObj.get("count").getAsLong();
		} catch (Exception e) {
			LOGGER.error("Error in getExemptedCount", e);
			throw new DataException(e);
		}
	}

	/**
	 * Gets the unique host by severity.
	 *
	 * @param index
	 *            the index
	 * @param severity
	 *            the severity
	 * @return the unique host by severity
	 * @throws DataException
	 *             the data exception
	 */
	public Map<String, Object> getUniqueHostBySeverity(String index, String severity) throws DataException {

		Map<String, Object> severityInfo = new HashMap<>();

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(index).append("/vulninfo/_search");
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"terms\":{\"severitylevel.keyword\":[");
		requestBody.append(severity);
		requestBody.append("]}}]}},\"aggs\":{\"severity\":{\"terms\":{\"field\":\"severitylevel.keyword\",\"size\":10}}}}");

		String responseDetails = "";
		try {
			responseDetails = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getUniqueHostBySeverity", e);
			throw new DataException(e);
		}

		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseDetails)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseDetails);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			JsonArray outerBuckets = aggsJson.getAsJsonObject("severity").getAsJsonArray(BUCKETS);
			if (outerBuckets.size() > 0) {
				for (int i = 0; i < outerBuckets.size(); i++) {
					severityInfo.put("S" + outerBuckets.get(i).getAsJsonObject().get("key").getAsString(),
							outerBuckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
				}
			} else {
				severityInfo.put("S3",0);
				severityInfo.put("S4",0);
				severityInfo.put("S5",0);
			}
		}
		return severityInfo;
	}

	/**
	 * Gets the compliant hosts by severity.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @return the compliant hosts by severity
	 * @throws DataException
	 *             the data exception
	 */
	public Map<String, Object> getCompliantHostsBySeverity(String assetGroup) throws DataException {

		Map<String, Object> severityInfo = new HashMap<>();

		List<String> nonCompliantResourceIds = getNonCompliantResourceIds(assetGroup);
		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(assetGroup).append("/vulninfo/_search");
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":true}},{\"terms\":{\"severitylevel.keyword\":[3,4,5]}}],\"must_not\":[{\"terms\":{\"_resourceid.keyword\":");
		requestBody.append(nonCompliantResourceIds);
		requestBody.append("}}]}},\"aggs\":{\"severity\":{\"terms\":{\"field\":\"severitylevel.keyword\",\"size\":10}}}}");

		String responseDetails = "";
		try {
			responseDetails = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getCompliantHostsBySeverity", e);
			throw new DataException(e);
		}

		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseDetails)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseDetails);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			JsonArray outerBuckets = aggsJson.getAsJsonObject("severity").getAsJsonArray(BUCKETS);
			if (outerBuckets.size() > 0) {
				for (int i = 0; i < outerBuckets.size(); i++) {
					severityInfo.put("S" + outerBuckets.get(i).getAsJsonObject().get("key").getAsString(),
							outerBuckets.get(i).getAsJsonObject().get(DOC_COUNT).getAsLong());
				}
			} else {
				severityInfo.put("S3",0);
				severityInfo.put("S4",0);
				severityInfo.put("S5",0);
			}
		}

		return severityInfo;
	}

	/**
	 * Gets the non compliant resource ids.
	 *
	 * @param index
	 *            the index
	 * @return the non compliant resource ids
	 * @throws DataException
	 *             the data exception
	 */
	public List<String> getNonCompliantResourceIds(String index) throws DataException {

		List<String> resourceIds = new ArrayList<>();

		StringBuilder urlToQuery = new StringBuilder(esUrl).append("/").append(index).append("/vulninfo/_search");
		StringBuilder requestBody = new StringBuilder(
				"{\"size\":0,\"query\":{\"bool\":{\"must\":[{\"match\":{\"latest\":\"true\"}},{\"terms\":{\"severitylevel.keyword\":[5]}}]}},"
						+ "\"aggs\":{\"resourceid\":{\"terms\":{\"field\":\"_resourceid.keyword\",\"size\":10000}}}}");

		String responseDetails = "";
		try {
			responseDetails = PacHttpUtils.doHttpPost(urlToQuery.toString(), requestBody.toString());
		} catch (Exception e) {
			LOGGER.error("Error in getNonCompliantResourceIds", e);
			throw new DataException(e);
		}

		JsonParser jsonParser = new JsonParser();
		if (StringUtils.isNotEmpty(responseDetails)) {
			JsonObject resultJson = (JsonObject) jsonParser.parse(responseDetails);
			JsonObject aggsJson = (JsonObject) jsonParser.parse(resultJson.get(AGGREGATIONS).toString());
			JsonArray outerBuckets = aggsJson.getAsJsonObject("resourceid").getAsJsonArray(BUCKETS);
			if (outerBuckets.size() > 0) {
				for (int i = 0; i < outerBuckets.size(); i++) {
					resourceIds.add(outerBuckets.get(i).getAsJsonObject().get("key").toString());
				}
			}
		}
		return resourceIds;
	}

	@SuppressWarnings("deprecation")
	public List<Map<String, Object>> fetchOrgInfoForApps() throws Exception {
		Map<String, Object> mustFilter = new HashMap<>();
		mustFilter.put(Constants.LATEST, Constants.TRUE);
		return elasticSearchRepository.getDataFromES("aws_apps", "apps", mustFilter, null, null,
				Arrays.asList("appTag", "_orgInfo.mgmntLevel", "_orgInfo.name", "_orgInfo.isOwner"), null);

	}

	public List<Map<String, Object>> getTrendProgress(String assetGroup, String ruleId, LocalDate startDate,
			LocalDate endDate, String trendCategory) throws DataException {
		Map<String, Object> mustFilter = new HashMap<>();
		mustFilter.put(CommonUtils.convertAttributetoKeyword("ag"), assetGroup);
		if ("issuecompliance".equals(trendCategory)) {
			mustFilter.put(CommonUtils.convertAttributetoKeyword("policyId"), ruleId);
		}

		Map<String, Object> rangeMap = new HashMap<>();
		rangeMap.put("gte", startDate.format(DateTimeFormatter.ISO_DATE));
		rangeMap.put("lte", endDate.format(DateTimeFormatter.ISO_DATE));

		Map<String, Object> dateRangeMap = new HashMap<>();
		dateRangeMap.put("date", rangeMap);

		mustFilter.put(RANGE, dateRangeMap);
		try {
			return elasticSearchRepository.getSortedDataFromES(AG_STATS, trendCategory, mustFilter, null, null,
					Arrays.asList("date", "total", "compliant", "noncompliant", "compliance_percent"), null, null);
		} catch (Exception e) {
			throw new DataException(e);
		}
	}

	public int vulnerabilityAssetsCount(String assetGroup, String targetType, Map<String, Object> mustFilter, int from,
			int size, Map<String, Object> mustTermsFilter) throws Exception {
		List<Map<String, Object>> results = new ArrayList<>();
		results = elasticSearchRepository.getSortedDataFromES(assetGroup, targetType, mustFilter, null, null, null,
				mustTermsFilter, null);
		return results.size();
	}
}